\chapter{The refinement algorithm}

\section{Description}

The given theory then lead to the development of a program
to solve the refinement problem for mvPDAs.
This program should eventually be integrated into a tool
for modal transitions systems called MoTraS \cite{Stoll11}.
Therefore, to maintain cross-platform compatibility, it
is written in Scala and Java, which allows to run on the JVM.
The program can also be used on its own from the command line.

Here we will describe the main parts of the program,
some finer implementation details, the basic usage and
show the performance results of several benchmarks.

\section{Implementation}

The essential parts of the algorithm are be shown here in pseudocode.
The main entry point is the function {\scfont{mvPDARefinement}} shown
in figure \ref{alg:mvpad-refining}.
It takes as input two initial processes $P⋅S$, $Q⋅T$ and an mvPDA.
It initialises the rules with the set of basic rules and enters a loop.
As long as there are two rules in the set of rules such that they can be combined
into new rules not completely contained in the set of rules, the new rules will be added.
This will compute the fixpoint of the set of rules under the combination of rules.
Then it returns if the refinement $P⋅S ≤_m Q⋅T$ holds by testing if the empty
rule is contained from the initial state.

\begin{figure}[H]
\begin{algorithmic}[1]
\Function{mvPDARefinement}{$P⋅S, Q⋅T, mvPDA$}
  \State $initial ← (P⋅S, Q⋅T)$
  \State $rules ← \Call{makeRules}{mvPDA}$
  \While{$\exists lhsRule, rhsRule ∈ rules :
      \Call{Combine}{lhsRule, rhsRule} ⊄ rules $}
    \State $rules ← rules ∪ \Call{combine}{lhsRule, rhsRule}$
  \EndWhile
  \State \textbf{return} $(initial, ∅) ∈ rules$
\EndFunction
\end{algorithmic}
\caption{Algorithm for testing refinement on an mvPDA}
\label{alg:mvpad-refining}
\vspace{-0.2cm} % TODO bad use
\end{figure}

\begin{figure}[H]
\begin{algorithmic}[1]
\Function{makeRules}{$mvPDA = (\Dmay, \Dmust)$}
  \State $rules ← ∅$
  \For{$P,Q,S,T ∈ Const(mvPDA), a ∈ Act(mvPDA)\}$}
    \LineComment{Attack from left-hand side for may rules}
      \State $lhs ← (P⋅S, Q⋅T)$
      \For{$(P⋅S, a, p') ∈ \Dmay$}
        \State $rhs ← ∅$
        \For{$(Q⋅T, a, q') ∈ \Dmay$}
          \State $rhs ← rhs ∪ \{ (p', q') \}$
        \EndFor
        \State $rules ← rules ∪ \{(lhs, rhs)\}$
      \EndFor
    \LineComment{Attack from right-hand side for must rules}
      \State $lhs ← (Q⋅T, P⋅S)$
      \For{$(Q⋅T, a, q') ∈ \Dmust$}
        \State $rhs ← ∅$
        \For{$(P⋅S, a, p') ∈ \Dmust$}
          \State $rhs ← rhs ∪ \{ (p', q') \}$
        \EndFor
        \State $rules ← rules ∪ \{(lhs, rhs)\}$
      \EndFor
  \EndFor
  \State \textbf{return} $rules$
\EndFunction
\end{algorithmic}
\caption{Algorithm for creating the basic attack rules on an mvPDA}
\label{alg:make-rules}
\end{figure}

\begin{figure}[H]
\begin{algorithmic}[1]
  \Function{combine}{$lhsRule = (lhs, lhsRhsSet), rhsRule = (rhsLhs, rhsSet)$}
  \State $rules ← ∅$
  \If{$\forall rhs ∈ rhsSet : size(rhs) = 1$}
    \For{$lhsRhs ∈ lhsRhsSet : lhsRhs = rhsLhs⋅p$}
      \State $newRhs ← (lhsRhsSet ∖ lhsRhs) ∪ \{ rhs⋅p \mid rhs ∈ rhsSet \}$
      \State $rules ← rules ∪ \{ (lhs, newRhs) \}$
    \EndFor
  \EndIf
  \State \textbf{return} $rules$
\EndFunction
\end{algorithmic}
\caption{Algorithm for combining attack rules}
\label{alg:rule-combining}
\end{figure}

The function {\scfont{makeRules}} shown in figure \ref{alg:make-rules}
takes an mvPDA as input and rules and returns the attack rules
that can be constructed out of the rewrite rules in the mvPDA.
This is basically the implementation of the inference rules 1 and 2
for attack rules.

The function {\scfont{combine}} shown in figure \ref{alg:make-rules}
then takes two rules and returns all rules that be constructed by
combining the two rules.
Note that the rules $lhsRule$ and $rhsRule$ are not required to
be actually left-hand side and right-hand side rules, but if they are
not, simply the empty set is returned.
Otherwise all combinations allowed by the inference rules 3 and 4
are formed and returned.

% TODO some more

\section{Soundness and completeness}

As the algorithm constructs exactly all the attack rules
allowed by the inference rules,
soundness follows from theorem \ref{theorem:refinement-tree} and
theorem \ref{theorem:tree-attack}.
For an input mvPDA with the refinement problem $P⋅S ≤_m Q⋅T$,
if the algorithm returns \textbf{true},
then $P⋅S ≤_m Q⋅T$, and if
if the algorithm returns \textbf{false},
then $¬(P⋅S ≤_m Q⋅T)$.

For completeness we only need to show that the algorithm always terminates.
The algorithm never adds a rule twice to its set of rules, and each iteration
of the while loop adds at least one rule.
The set of possible attack rules over a finite set of constants is finite,
and the algorithm only uses constants from the finite mvPDA, therefore it
will terminate.

\section{Complexity}

Let $k = |Const|$ be the number of constants appearing in the input mvPDA.
For a rule $(p,q) \attack S$, as
$(p, q) ∈ \{ (P⋅S,Q⋅T) \mid P,S,Q,T ∈ Const \}$, there are $k^4$ possible states for $(p,q)$.
F or each $(p',q') ∈ S$, as $(p',q') ∈ \{ (p,q) \mid |p| ≤ 3 ∧ |q| ≤ 3 ∧ p,q \text{ sequential} \}$,
there are at most $k^6$ possible states. With the number of subsets $S$ being in
$\mathcal O(2^{k^6})$, the number of possible rules is in $\mathcal O(k^4 2^{k^6})$.
The main loop of the algorithm is executed at most once for every possible rules,
and its body can iterate over every rule created so far a constant amount of times $d$.
An input of size $n$ can define $\mathcal O(n)$ constants, therefore the worst-case
complexity is $\mathcal O\left( n^4 2^{c' \cdot n^6} \right)^d =
\mathcal O\left( n^{4d} 2^{d \cdot n^6} \right) =
\mathcal O(2^{c \cdot n^6}) ⊆ \text{EXPTIME}$
for some constant $c$.
The refinement problem on mvPDA is EXPTIME-complete \cite{BenesK12}, indicating there
is quite possibly no better solution.

% TODO: need n^3 rules?
However the worst case is only achieved by certain rule structures.
To actually construct $k^6$ different right-hand sides from a state,
it seems that $k^3$ rules are necessary, which would imply
a complexity of $\mathcal O(2^{c \cdot n^2})$.
This would be in accordance with \cite{Walukiewicz96}.
Further for many types inputs where the global branching degree is constant
only polynomial time is needed, as shown later.

\section{Optimizations}

The algorithm as given above in pseudocode gives a naive implementation and can be improved
in several ways. While these do not reduce the worst-case complexity,
on many inputs a significant speedup is measurable.
The following are the main optimizations used in the actual implementation.

\paragraph{Worklist algorithm}

Instead of iterating over the entire set of rules to find matching rules, new rules are
added to a worklist.
The main loop of the algorithm removes new rules from the worklist one at a time, adds
the new rule to the set of rules and combines it with all matching rules.
Newly obtained rules are then added to the worklist again. 

\paragraph{Hash map lookup}

Again for finding a matching rules, iterating over all rules can take exponential time.
A better approach is to separate the rules into left-hand side rules and right-hand side
rules, and for each state $(P⋅S,Q⋅T)$, keep a reference to all rules of each type
that apply from that state.
Specifically, if we have a rule $(p,q) \attack S$, if it is a right-hand side rule keep
a reference to that rule from $(p,q)$, and if it is left-hand side rule keep a reference
from each $(P⋅S,Q⋅T)$ where $(P⋅S,Q⋅T) ∈ S$ or $(P⋅S⋅S', Q⋅T⋅T') ∈ S$.
That way, after taking a rule from the worklist, matching can be performed in time linear
to the number of matching rules. However there still might be an exponential number
of matching rules.

\paragraph{Keeping only minimial rules}

When there are two attack rules $(p,q) \attack S$ and $(p,q) \attack S'$ with
$S ⊆ S'$, only the smaller needs rule $(p,q) \attack S$ needs to be kept and
$(p,q) \attack S'$ can be removed.
If we can obtain $(p,q) \attack ∅$ from a sequence that reduces $S'$,
we can also obtain it from $S$.
On the other hand, if there is no sequence that reduces $S'$,
then there is also no sequence that reduces $S$.
Therefore the correctness of the algorithm is not affected.

\paragraph{Removing rules that are not useful}
% TODO

\paragraph{Heuristic for combining rules}

With the optimization to only keep minimal rules, we would like to obtain these
as early as possible. While finding the optimal strategy is as hard as solving the
problem, a suitable heuristic is to choose rules $(p,q) \attack S$ with the smallest
$S$ first.
This strategy especially for non-refining process, where we rules have $S=∅$,
which always leads to smaller rules.
For the implementation, this means using a priority queue as the worklist.

\paragraph{Reachable state exploration}

Instead of initialising the set of rules with rules from all possible states,
we can add rules as we reach a state.
Reachability is decidable on PDAs \cite{BouajjaniEM97} and we can apply that
to the combined states of our attack rules.
We start with the initial state, and whenever we obtain a new state on the right-hand
side as an internal or call state, we add the attack rules from that state.
This also reduces the added complexity of combining two mvPDA with no shared states
into a single mvPDA.

\paragraph{Early stopping}

Instead of computing all possible rules and then testing if the empty is obtained,
we can stop as soon as we find $(P⋅S,Q⋅T) \attack ∅$ and return \textbf{false}.
However, this only improves the runtime if the processes do not refine.
If they refine, the algorithm has to explore all the possible rules before
returning \textbf{true}.

\section{Usage}

The refinement algorithm can be called from the command line via
\begin{verbatim}
java -jar vmpda-refinement.jar <files>
\end{verbatim}
where \verb+<files>+ is a list of space-separated input files.

% TODO: verbosity?

% TODO: how to call it
% environment, java version, scala

\subsection{Input}

Each input for the program is given in a file containing the processes
to test for refinement and the rewrite rules of the mvPDA.
The file format used here is similiar to ones used in existing
tools \cite{Sickert12} to ease the integration with the MoTraS tool.
In figure \ref{fig:grammar} the grammar is given. For clarity,
whitespace is not explicitly noted, but needed between identifiers.
At other places it is ignored.

A valid input needs to specify $\left< mprs \right>$ with the refinement problem and
the rules.
Note that any mPRS can be defined in the grammer, but the algorithm
tests if it is an actual mvPDA and outputs an error otherwise.
After parsing the input, the algorithm may rewrite the processes
to bring them in a normal form in accordance to the congruence relation
of the operators.

\begin{figure}
\paragraph{mPRS definition}
\begin{grammar}
<mprs> ::= "mprs" <id> "[" <refinement> <rule>* "]"

<refinement> ::= <process> "<=" <process>

\end{grammar}

\paragraph{Rule definition}
\begin{grammar}
<rule> ::= <process> <action> <ruletype> <process>

<action> ::= <id>

<ruletype> :: = <mayrule> | <mustrule>

<mayrule> :: = "?"

<mustrule> :: = "!"
\end{grammar}

\paragraph{Process definition}
\begin{grammar}
<process> ::= <empty> | <constant> | <parallel> | <sequential> | "(" <process> ")"

<empty> ::= "_"

<constant> ::= <id>

<parallel> ::= <process> "." <process>

<sequential> ::= <process> "|" <process>
\end{grammar}

\paragraph{Common definitions}
\begin{grammar}
<letter> ::= "a" | … | "z" | "A" | … | "Z"

<digit> ::= "0" | …  | "9"

<id> ::= <letter>(<letter> | <digit>)*
\end{grammar}
\caption{Grammar for the input files}
\label{fig:grammar}
\end{figure}

\newpage % TODO remove

\begin{example}
Listing \ref{listing:mprs-input} gives the
input for our vending machine mvPDA from figure \ref{fig:vending-mvpda}.
\end{example}

\begin{figure}[ht]
\lstinputlisting{example.mprs}
\caption{Input representing the vending machine mvPDA}
\label{listing:mprs-input}
\end{figure}

% now command line
% future integration with gui
% similiar input file to existing programs

% TODO

%Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.

%\subsection{Calling the programm}

\subsection{Output}

After calling the program with a list of input files, the program prints
a line with the result of the refinement test for each input.
The line consists of a result code, the filename and the running time
in case of successful execution. The result codes are explained in
figure \ref{fig:result-codes}.

\begin{figure}[ht]
  \centering
  \begin{tabular}{l|l}
    Result code & Meaning \\
    \hline
    {0} & The processes refine \\
    {1} & The processes do not refine  \\
    {E} & There was an exception
  \end{tabular}
  \caption{Result codes}
  \label{fig:result-codes}
\end{figure}

Possible causes for exceptions are I/O Exceptions when reading the file,
parsing exceptions for malformed input or illegal argument exceptions
when the input does not represent an mvPDA.

\begin{example}
Figure \ref{listing:usage-output} shows the output from the run
of the program on three input files. The first one is the vending machine mvPDA
and the algorithm shows it does not refine, the second one is refining example
and the third is an invalid input, where the given mPRS is not an mvVPDA.
\end{example}

\begin{figure}[ht]
\lstinputlisting{output.txt}
\caption{Usage example}
\label{listing:usage-output}
\end{figure}

\section{Performance evaluation}

As seen in the complexity analysis,

It is int

On vPDAs, and even more on mvPDAs, there is not

Quickly intractable

only may
just three actions

benchmarks
% TODO

\paragraph{High branching degree}

test $P_0⋅S_0 ≤_m Q_0⋅S_0$.

\begin{figure}[ht]
  \centering
  \begin{minipage}[b]{.45\textwidth}
    \begin{align*}
      P_0⋅S_0 &\may[c] P_1⋅S_0⋅S_0 \\
      P_0⋅S_0 &\may[r] P_2 \\
      P_2⋅S_0 &\may[c] P_3⋅S_0⋅S_0 \\
      P_3⋅S_0 &\may[i] P_4⋅S_0 \\
      P_4⋅S_0 &\may[r] P_5 && \text{if }¬ref
    \end{align*}
  \end{minipage}\quad
  \begin{minipage}[b]{.45\textwidth}
    \begin{align*}
      Q_0⋅S_0 &\may[c] Q_1⋅S_0⋅S_i && ∀0 ≤ i < n \\
      Q_1⋅S_0 &\may[r] Q_2 \\
      Q_2⋅S_i &\may[c] Q_3⋅S_0⋅S_i && ∀0 ≤ i < n \\
      Q_3⋅S_0 &\may[i] Q_4⋅S_i && ∀0 ≤ i ≤ n \\
    \end{align*}
  \end{minipage}
  \caption{mvPDA with high branching degree}
  \label{fig:mvpda-high-branching}
\end{figure}

\begin{figure}[ht]
\centering
  \begin{minipage}[b]{.45\textwidth}
    \includegraphics{./graphs/bench_wide_flat_time.pdf}
  \end{minipage}
  \hspace{0.5cm}
  \begin{minipage}[b]{.45\textwidth}
    \includegraphics{bench_wide_flat_rules.pdf}
  \end{minipage}
  \caption{Benchmark for mvPDA with high branching degree}
  \label{fig:bench-high-branching}
\end{figure}

\paragraph{Trees with high global width}

\begin{figure}[ht]
  \centering
  \begin{minipage}[b]{.45\textwidth}
    \begin{align*}
      P_{1,i}⋅S &\may[c] P_{1,i + 1}⋅S⋅S && ∀ 0 ≤ i < n \\
      P_{1,n}⋅S &\may[i] P_{2,n}⋅S \\
      P_{2,i + 1}⋅S &\may[r] P_{2,i} && ∀ 0 ≤ i < n \\
      P_{2,0}⋅S &\may[i] P_{3,0} \text{if }¬ref \\
    \end{align*}
  \end{minipage}\quad
  \begin{minipage}[b]{.45\textwidth}
    \begin{align*}
      Q_{1,i}⋅S &\may[c] Q_{1,i}⋅S⋅S && ∀ 0 ≤ i < n \\
      Q_{1,i}⋅S &\may[c] Q_{1,i + 1}⋅S⋅S && ∀ 0 ≤ i < n \\
      Q_{1,i}⋅S &\may[i] Q_{2,i}⋅S && ∀ 0 ≤ i < n \\
      Q_{2,i}⋅S &\may[r] Q_{3,i} && ∀ 0 ≤ i < n
    \end{align*}
  \end{minipage}
  \caption{mvPDA with high maximum width tree}
  \label{fig:mvpda-max-width}
\end{figure}

\begin{figure}[ht] % TODO redo benchmark
\centering
  \begin{minipage}[b]{.45\textwidth}
    \includegraphics{bench_wide_deep_time.pdf}
  \end{minipage}
  \hspace{0.5cm}
  \begin{minipage}[b]{.45\textwidth}
    \includegraphics{bench_wide_deep_rules.pdf}
  \end{minipage}
  \caption{Benchmark for mvPDA with high maximum width tree}
  \label{fig:bench-max-width}
\end{figure}

\paragraph{Trees with constant maximum width}

no significant differences between
refining and non-refining processes.

\begin{figure}[ht]
  \centering
  \begin{minipage}[b]{.45\textwidth}
    \begin{align*}
      P_{1,i}⋅S &\may[c] P_{1,i}⋅S⋅S && ∀ 0 ≤ i < n \\
      P_{1,i}⋅S &\may[c] P_{1,i + 1}⋅S⋅S && ∀ 0 ≤ i < n \\
      P_{1,n}⋅S &\may[i] P_{2,n}⋅S \\
      P_{2,i + 1}⋅S &\may[r] P_{2,i} && ∀ 0 ≤ i < n \\
      P_{2,n}⋅S &\may[i] P_{3,0}⋅S \text{if }¬ref \\
    \end{align*}
  \end{minipage}\quad
  \begin{minipage}[b]{.45\textwidth}
    \begin{align*}
      Q_{1,i}⋅S &\may[c] Q_{1,i}⋅S⋅S && ∀ 0 ≤ i < k \\
      Q_{1,i}⋅S &\may[c] Q_{1,i + 1}⋅S⋅S && ∀ 0 ≤ i < k \\
      Q_{1,i}⋅S &\may[i] Q_{2,i}⋅S && ∀ 0 ≤ i < k \\
      Q_{2,i}⋅S &\may[r] Q_{3,i} && ∀ 0 ≤ i < k
    \end{align*}
  \end{minipage}
  \caption{mvPDA with constant maximum width tree}
  \label{fig:mvpda-const}
\end{figure}

\begin{figure}[ht] % TODO redo benchmark
\centering
  \begin{minipage}[b]{.45\textwidth}
    \includegraphics{bench_const_deep_time.pdf}
  \end{minipage}
  \hspace{0.5cm}
  \begin{minipage}[b]{.45\textwidth}
    \includegraphics{bench_const_deep_rules.pdf}
  \end{minipage}
  \caption{Benchmark for mvPDA with constant maximum width tree}
  \label{fig:bench-const}
\end{figure}

