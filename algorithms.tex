\chapter{The refinement algorithm}

\section{Description}

% TODO

Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.

Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.

\section{Implementation}

Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.

% pseudocode
\begin{figure}[ht]
\caption{Algorithm for calculating the basic attack rules on mvPDAs}
\begin{algorithmic}[1]
\Function{AttackRules}{$mvPDA = (\Dmay, \Dmust)$}
  \State $rules ← ∅$
  \For{$P,Q,S,T ∈ Const(mvPDA), a ∈ Act(mvPDA)\}$}
    \LineComment{Attack from left-hand side for may rules}
      \State $lhs ← (P⋅S, Q⋅T)$
      \For{$(P⋅S, a, p') ∈ \Dmay$}
        \State $rhs ← ∅$
        \For{$(Q⋅T, a, q') ∈ \Dmay$}
          \State $rhs ← rhs ∪ \{ (p', q') \}$
        \EndFor
        \State $rules ← rules ∪ \{(lhs, rhs)\}$
      \EndFor
    \LineComment{Attack from right-hand side for must rules}
      \State $lhs ← (Q⋅T, P⋅S)$
      \For{$(Q⋅T, a, q') ∈ \Dmust$}
        \State $rhs ← ∅$
        \For{$(P⋅S, a, p') ∈ \Dmust$}
          \State $rhs ← rhs ∪ \{ (p', q') \}$
        \EndFor
        \State $rules ← rules ∪ \{(lhs, rhs)\}$
      \EndFor
  \EndFor
  \State \textbf{return} $rules$
\EndFunction
\end{algorithmic}
\end{figure}

Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.

\begin{figure}[ht]
\caption{Algorithm for combining attack rules}
\begin{algorithmic}[1]
  \Function{Combine}{$lhsRule = (lhs, lhsRhsSet), rhsRule = (rhsLhs, rhsSet)$}
  \State $rules ← ∅$
  \If{$\forall rhs ∈ rhsSet : size(rhs) = 1$}
    \For{$lhsRhs ∈ lhsRhsSet : lhsRhs = rhsLhs⋅p$}
      \State $newRhs ← (lhsRhsSet ∖ lhsRhs) ∪ \{ rhs⋅p \mid rhs ∈ rhsSet \}$
      \State $rules ← rules ∪ \{ (lhs, newRhs) \}$
    \EndFor
  \EndIf
  \State \textbf{return} $rules$
\EndFunction
\end{algorithmic}
\end{figure}

Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.

\begin{figure}[ht]
\caption{Refinement algorithm for mvPDAs}
\begin{algorithmic}[1]
\Function{VPDARefinement}{$P⋅S, Q⋅T, mvPDA$}
  \State $initial ← (P⋅S, Q⋅T)$
  \State $rules ← \Call{AttackRules}{mvPDA}$
  \While{$\exists lhsRule, rhsRule ∈ rules :
      \Call{Combine}{lhsRule, rhsRule} ⊄ rules $}
    \State $rules ← rules ∪ \Call{Combine}{lhsRule, rhsRule}$
  \EndWhile
  \State \textbf{return} $(initial, ∅) ∈ rules$
\EndFunction
\end{algorithmic}
\end{figure}

\section{Soundness and completeness}

Soundness follows from theorem \ref{theorem:refinement-tree} and
theorem \ref{theorem:tree-attack}.
For an input mvPDA with the refinement problem $P⋅S ≤_m Q⋅T$,
if the algorithm returns \textbf{true},
then $P⋅S ≤_m Q⋅T$, and if
if the algorithm returns \textbf{false},
then $¬(P⋅S ≤_m Q⋅T)$.

For completeness we only need to show that the algorithm always terminates.
The algorithm never adds a rule twice to its set of rules, and each iteration
of the while loop adds at least one rule.
As the set of possible attack rules over a finite set of constants is finite,
and the algorithm only uses constants from the finite mvPDA, termination
follows directly.

% proof: no refinement => algorithm outputs false
% proof: algorithm outputs false => no refinement
% termination proof

\section{Runtime}

Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.

% tests with complete number

\section{Optimizations}

The algorithm as given above in pseudocode gives a naive implementation and can be improved
in several ways. While these do not reduce the worst-case complexity,
on many inputs a significant speedup is measurable.
The following are the main optimizations used in the actual implementation.

\paragraph{Worklist algorithm}

Instead of iterating over the entire set of rules to find matching rules, new rules are
added to a worklist.
The main loop of the algorithm removes new rules one at a time, adds
the new rule to the set of rules and combines it with all matching rules.
Newly obtained rules are then added to the worklist again. 

\paragraph{Hash map lookup}
% hash map for looking up lhs/rhs

Again for finding a matching rules, iterating over all rules can take exponential time.
A better approach is to seperate the rules into left-hand side rules and right-hand side
rules, and for each state $(P⋅S,Q⋅T)$, keep a reference to all rules of each type
that apply from that state.
Specifically, if we have a rule $(p,q) \attack S$, if it is a right-hand side rule keep
a reference to that rule from $(p,q)$, and if it is left-hand side rule keep a reference
from each $(P⋅S,Q⋅T)$ where $(P⋅S,Q⋅T) ∈ S$ or $(P⋅S⋅S', Q⋅T⋅T') ∈ S$.
That way, after taking a rule from the worklist matching can be performed in time linear
to the number of matching rules.

\paragraph{Keeping only minimial rules}
% only keep smallest rhs rules

When there are two attack rules $(p,q) \attack S$ and $(p,q) \attack S'$ with
$S ⊆ S'$, only the smaller needs rule $(p,q) \attack S$ needs to be kept and
$(p,q) \attack S'$ can be removed.
If we can obtain $(p,q) \attack ∅$ from a sequence that reduces $S'$,
we can also obtain it from $S$.
On the other hand, if there is no sequence that reduces $S'$,
then there is also no sequence that reduces $S$.
Therefore the correctness of the algorithm is not affected.

\paragraph{Heuristic for combining rules}
% try to use rules with smaller right-hand side first

With the optimization to only keep minimal rules, we would like to obtain these
as early as possible. While finding the optimal strategy is as hard as solving the
problem, a suitable heuristic is to choose rules $(p,q) \attack S$ with the smallest
$S$ first.
This strategy especially for non-refining process, where we have $S=∅$, which always
leads to smaller rules.
For the implementation, this means using a priority queue as the worklist.

\paragraph{Reachable state exploration}
% exploration of reachable states

Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.

\paragraph{Early stopping}
% early stopping

Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.

\section{Usage}

Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.
% environment, java version, scala

\subsection{Input}

similiar to existing tools \cite{Sickert12}.
integrating into existing tools \cite{Stoll11}.

any mPRS, not just mvPDA
processes brought into normal form

Whitespace is needed between keywords, but otherwise ignored.

\begin{figure}
\paragraph{mPRS definition}
\begin{grammar}
<mprs> ::= "mprs" <id> "[" <refinement> <rule>* "]"

<refinement> ::= <process> "<=" <process>

\end{grammar}

\paragraph{Rule definition}
\begin{grammar}
<rule> ::= <process> <action> <ruletype> <process>

<action> ::= <id>

<ruletype> :: = <mayrule> | <mustrule>

<mayrule> :: = "?"

<mustrule> :: = "!"
\end{grammar}

\paragraph{Process definition}
\begin{grammar}
<process> ::= <empty> | <constant> | <parallel> | <sequential> | "(" <process> ")"

<empty> ::= "_"

<constant> ::= <id>

<parallel> ::= <process> "." <process>

<sequential> ::= <process> "|" <process>
\end{grammar}

\paragraph{Common definitions}
\begin{grammar}
<letter> ::= "a" | … | "z" | "A" | … | "Z"

<digit> ::= "0" | …  | "9"

<id> ::= <letter>(<letter> | <digit>)*
\end{grammar}
\label{fig:grammar}
\caption{Grammar for input file}
\end{figure}

% TODO ref
\lstinputlisting[caption=Input representing the vending machine mvPDA, label=listing:mprs-input]{example.mprs}

\lstinputlisting[caption=Usage example, label=listing:usage-output]{output.txt}

% now command line
% future integration with gui
% similiar input file to existing programs

Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.

\subsection{Calling the programm}

\subsection{Output}

% table of error codes

Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.

\section{Performance evaluation}

% TODO

%\paragraph{Refining processes}

% Family of processes that refine

%\paragraph{Non-refining processes}

% Family of processes that do not refine

%\paragraph{Random processes}

% Random PRS

