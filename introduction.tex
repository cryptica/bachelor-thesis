\pagenumbering{arabic}

\newpage

\chapter{Introduction}

As an extension to labeled transition systems,
modal transition systems (MTS) \cite{LarsenT88}
have been widely used, especially in model checking.
They provide a way to describe system specifications
in a way that allows stepwise refinement
and composition of several refinements.
An MTS has two types of transitions, \emph{may} transitions, which are admissible,
and \emph{must} transitions, which are necessary.
A refinement of an MTS should then still be able to perform
all must transitions and all transitions it can perform are may transitions.
This way one can gradually produce finer specifications that still conform
to the original specification, until one arrives at a concrete implementation.
Alternatively one can produce coarser specifications for abstraction.
A central problem then is to decide whether modal refinement holds between
two systems.

There are many types of MTS, 
but formalisms to describe modal transitions systems with
an infinite state space have only been explored recently \cite{BenesK12}.
For transitions systems, one powerful framework to describe them are
process rewrite systems (PRS) \cite{Mayr00, Esparza01}.
They can be used to model many widely used systems
such as pushdown automata (PDA) or Petri nets (PN).
By lifting PRS to the modal world, we obtain mPRS
and their respective modal transitions systems such as
mPDA or mPN.

Unfortunately, even for basic classes such as
stateless PDA, known as basic process algebras (BPA), already simulation is
undecidable \cite{GrooteH94}.
As refinement is a generalization of both simulation and bisimulation,
it is also undecidable on mBPA and mPDA.

However there is the subclass of visibly pushdown automata (vPDA),
which is closed under all desirable operations
and for which most problems are decidable \cite{AlurM04}.
They restrict the rules of a PDA by making visible which
actions push a symbol on a stack and which pop one.
They are still more expressive than finite automata 
and can be used to specify certain properties about the stack.
For example, they have been applied to check
parenthesis-like matching in XML streaming
\cite{KumarMV07}
and checking pre/post-conditions for module calls
in program analysis \cite{AlurEM04}.

Therefore we would like to use the modal view on vPDA
as well to allow modal specifications and abstractions.
This requires a way to test refinement between these.
Fortunately, not only simulation and bisimulation
is decidable \cite{Srba06},
but also modal refinement \cite{BenesK12}.
Based on that result, we present
an algorithm with its underlying theory
to decides modal refinement on mvPDA.



