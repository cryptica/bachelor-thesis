\chapter{Theory}

\section{Basic definitions}

Processes are terms combined with parallel or sequential composition.

The syntax here is taken from \cite{Mayr00} and \cite{Esparza01}.

% processes are parallel or sequential

\begin{definition}[Process]

The set of processes $\mc P$ over a set of constants $Const$ is given by
\begin{mathpar}
  \inferrule{ }{ε ∈ \mc P}\, (0) \hspace{1cm}
  \inferrule{X ∈ Const}{X ∈ \mc P}\, (1) \hspace{1cm}
  \inferrule{p ∈ \mc P \\ q ∈ \mc P}{p⋅q ∈ \mc P}\, (S) \hspace{1cm}
  \inferrule{p ∈ \mc P \\ q ∈ \mc P}{p\|q ∈ \mc P}\, (P)
\end{mathpar}
Processes are considered modulo the usual structural congruence, i.e.
the smallest congruence such that the operator $⋅$ is associative,
$\|$ is associative and commutative and
$ε$ is a unit for both $⋅$ and $\|$.

From here on we will denote processes by lowercase letters $p,q,…$ and single
constants by uppercase letters $P,Q,…$.
\end{definition}

The class of processes that can be produced just with rule 0, 1 and S, i.e. contain no $\|$,
is the class of \emph{sequential processes} \textbf{S}.
The class of processes that can be produced just with rule 0, 1 and P, i.e. contain no $⋅$,
is the class of \emph{parallel processes} \textbf{P}.
% TODO add constant or general processes?

The size of a process will be defined by the number of constants appearing in it.

\begin{definition}[Size of a process]
  The size $|p|$ of a process term $p$ is defined by
  \begin{align*}
    |ε| &= 0 \\
    |X| &= 1 \\
    |p⋅q| &= |p| + |q| \\
    |p \| q| &= |p| + |q|
  \end{align*}
\end{definition}

\section{Modal transition system}

Modal process rewrite systems \cite{BenesK12} are a modal extension of 
process rewrite system. 
There are two types of transitions, may and must transitions.

Modal transition system definition from \cite{BenesK12}:
\begin{definition}[Modal transition system]
A \emph{modal transition system (MTS)} over an action alphabet $Act$ is
a triple $(\mc P, \may[], \must[])$ where $\mc P$ is a set of processes %TODO tripel? tuple?
$\must[] ⊆ \may[] ⊆ \mc P × Act × \mc P$.
An element $(p,a,q) ∈ \may[]$ is a \emph{may transition}, also written as $p \may[a] q$,
and an element $(p,a,q) ∈ \must[]$ is a \emph{must transition}, also written as $p \must[a] q$.
\end{definition}

\section{Modal refinement}

Modal refinement of one process of another.
May transitions may be present in the refinement, while must transitions must be present.
In the other directions, only may
A must transition always has a corresponding may transition.

Out of simplicity, we regard only modal refinment for two processes from a single MTS.
Modal refinement of processes from two different MTS can be reduced to this by taking
the disjoint union of the MTS.

\begin{definition}[Refinement]
  Let $(\mc P, \may, \must)$ be an MTS
  and $p,q ∈ \mc P$ be processes.
  We say that $p$ \emph{refines} $q$, written $p ≤_m q$, if there is a relation
  $\mc R ⊆ \mc P × \mc P $ such that
  $(p, q) ∈ \mc R$ and for every $(p, q) ∈ \mc R$ and every $a ∈ Act$:
  \begin{enumerate}
    \item If $p \may[a] p'$ then there is a transition $q \may[a] q'$ s.t.
          $(p',q') ∈ \mc R$.
    \item If $q \must[a] q'$ then there is a transition $p \must[a] p'$ s.t.
          $(p',q') ∈ \mc R$.
  \end{enumerate}
  Modal refinement can also be seen as a refinement game from a pair of processes
  $(p,q)$ where each side plays an attacking transition and the other a defending transition
  to reach a new state.

  Thus if from the state $(p,q)$ there is a transition $p \may[a] p'$ or $q \may[a] q'$,
  we will call this an \emph{attacking transition} and a transition
  $q \may[a] q'$ or $p \must[a] p'$ from that state matching the type and action of
  the attacking transition a \emph{defending transition}.
  
  Then $p ≤_m q$ holds if there no winning strategy from $(p,q)$, i.e.
  a sequence of attacking transitions such that for every choice of defending transition
  we will reach a state $(p',q')$ from which there is an attacking transition but no
  defending transition.
\end{definition}

\section{Modal process rewrite system}

\begin{definition}[Modal process rewrite system]
A \emph{process rewrite system (PRS)} over an action alphabet $Act$
is a finite relation $Δ ⊆ \mc P ∖ \{ε\} × Act × \mc P$.
Elements of $Δ$ are called \emph{rewrite rules}.
A \emph{modal process rewrite system (mPRS)} is a tuple $(\Dmay, \Dmust)$ where
$\Dmay, \Dmust$ are process rewrite systems such that $\Dmay ⊆ \Dmust$.

An mPRS $(\Dmay, \Dmust)$ induces an MTS $(\mc P, \may[], \must[])$ as follows:
\begin{mathpar}
  \inferrule{(p, a, p') ∈ \Dmay}{p \may[a] p'} \, (1) \quad
  \inferrule{(p, a, p') ∈ \Dmust}{p \must[a] p'} \, (2) \\
  \inferrule{p \may[a] p'}{p⋅q \may[a] p⋅q} \, (3) \quad
  \inferrule{p \must[a] p'}{p⋅q \must[a] p'⋅q} \, (4) \quad
  \inferrule{p \may[a] p'}{p\|q \may[a] p\|q} \, (5) \quad
  \inferrule{p \must[a] p'}{p\|q \must[a] p'\|q} \, (6)
\end{mathpar}
\end{definition}

\section{Attack tree}

\begin{definition}[Attack tree]

  An \emph{attack tree} over a set of processes $\mc P$ is a rooted tree where
  each node has two kinds of children.
  It is given by a triple $((p,q),O,C)$,
  representing the tree with the root node labeled by $(p,q) ∈ \mc P^2$,
  the set of open edges $O$ leading to states $(p',q') ∈ \mc P^2$ and
  the set of closed edges $C$ leading to the attack trees that are children of the
  root node.
  
  For an attack tree $T = ((p,q),O,C)$, we will use the short notations
  $T_r = (p,q)$ for the root, $T_O = O$ for the set of states open edges lead to
  and $T_C = C$ for the set of subtrees closed edges lead to.
  
  The set of attack trees $\mc T$ constructable from an MTS $(\mc P, \may, \must)$
  are defined inductively by:
  \begin{mathpar}
    \inferrule{p,q ∈ \mc P, p \may[a] p'}
      {((p,q), \{ (p', q') \mid q \may[a] q' \}, ∅) ∈ \mc T}
    \, (1) \\
    \inferrule{p,q ∈ \mc P, q \must[a] q'}
      {((p,q), \{ (p', q') \mid p \must[a] q' \}, ∅) ∈ \mc T}
    \, (2) \\
    %\inferrule{((p,q), O \uplus (p', q'), C) ∈ \mc T \\ T = ((p', q'), O', C') ∈ \mc T}
    %  {(s, O, C ∪ \{T\}) ∈ \mc T}
    %\, (3) \\
    \inferrule{T ∈ \mc T \\ R ∈ \mc T \\ R_r ∈ T_O}
      {(T_r, T_O ∖ \{R_r\}, T_C ∪ \{R\}) ∈ \mc T}
    \, (3) \\
  \end{mathpar}
  
  Rules 1 and 2 specify an initial tree for an attacking rule with the possible defensive
  states while rule 3 replaces an open edge to a state with a tree with that state as its
  root.

  As we can see from the construction rules, every tree
  has a corresponding attacking transition from the root node, while for each defending transition
  applicable from that state and attacking transition there is an edge to either an open state or
  a subtree. Therefore we can identify nodes with attacking transitions and edges with
  defending transitions.

  The sot of all \emph{subtrees} of $T$, including $T$ itself, are given recursively by
  $subtree(T) = T ∪ ⋃_{T' ∈ T_C} subtree(T')$.
  
  The set of all \emph{open states} of $T$ are the states that
  have an open edge to it, that is $open(T) = ⋃_{T' ∈ subtree(T)} T'_O$.
  
  We say that a tree is \emph{closed} if it has no open states, that is
  $closed(T)$ \iff $open(T) = ∅$.

\end{definition}

\begin{lemma}[Tree composition]
  \label{lemma:tree-composition}
  If there are attack trees $T$ and $R$ with
  $R_r ∈ open(T)$,
  then there is an attack tree $S$ with
  $S_r = T_r$ and
  $open(S) = open(T) ∖ \{R_r\} ∪ open(R)$.
  and $s ∈ T_O$
\end{lemma}
\begin{proof}
  For every subtree $T' ∈ subtree(T)$
  with $R_r ∈ T'_O$, we can construct
  $S' = (T'_r, T'_O ∖ \{R_r\}, T'_C ∪ \{R\}$ with
  $open(S') = T'_O ∖ \{R_r\} ∪ open(R)$.
  Th tree $S'$ can be added as a subtree whenever $T'$ could be,
  be used in the construction rules as $T$.
  $open(S) = (⋃_{T' ∈ subtree(T) \| R_r ∈ T'_O} S'_O)$
  $ ∪ (⋃_{T' ∈ subtree(T) \| R_r ∉ T'_O} T'_O)$
  $= (⋃_{T' ∈ subtree(T) \| R_r ∈ T'_O} T'_O ∖ \{R_r\} ∪ open(R)$.
  $ ∪ (⋃_{T' ∈ subtree(T) \| R_r ∉ T'_O} T'_O ∖ \{R_r\})$
  $= (⋃_{T' ∈ subtree(T)} T'_O) ∖ \{R_r\} ∪ open(R)$.
  $= open(T) \{R_r\} ∪ open(R)$.
\end{proof}
\begin{proof}
  We prove the proposition by induction on the number of child trees
  with an open edge to $R_r$, that is
  $n = |\{ T' ∈ T_C \mid R_r ∈ open(T')\}|$:
  \begin{enumerate}
    \item $n = 0$:
      Then $R_r ∈ T_O$ and $T_r ∉ open(T')$ for $T' ∈ T_C$
      and we can construct
      $S = ((p,q), T_O ∖ \{R_r\}, T_C ∪ \{R\})$ with
      $open(S) = open(T) ∖ \{R_r\} ∪ open(R)$
    \item $n ≥ 1$:
      Then there is $T' ∈ T_C$ such that $R_r ∈ open(T')$.
      By induction hypothesis there is
      $S'$ with $S'_r = T'_r$ and
      $open(S') = open(T') ∖ \{R_r\} ∪ open(R)$

      As $T'$ was added to $T_C$ some point in the construction of $T$,
      we can substitute $T'$ with $S'$ and obtain
      $T''$ with $T''_r = T_r$, $T''_O = T_O$ and
      $T''_C = T_C ∖ \{T'\} ∪ \{S'\}$.
      We have $open(T'') = T_O ∪ (⋃_{R' ∈ T_C ∖ \{T'\} } open(R')) ∪ open(S')$.

      If $R_r ≠ open(T'')$, then $open(T'') = open(T) ∖ \{R_r\} ∪ open(R)$ and we are done.
      Otherwise $T''$ has less children with an open edge to
      $R_r$, therefore we
      can apply the induction hypothesis on it and obtain
      $S$ with $S_r = T_r$ and
      $open(S) = open(T'') ∖ \{R_r\} ∪ open(R) = open(T) ∖ \{R_r\} ∪ open(R)$.
  \end{enumerate}
\end{proof}

% TODO relation tree <-> refinement

\begin{theorem}[Attack tree refinement]
  \label{theorem:refinement-tree}
  For an MTS $(\mc P, \may, \must)$ and processes $p,q ∈ \mc P$:
  \[
    (p ≤_m q) \iff ¬∃ T ∈ \mc T : T_r = (p,q) ∧ closed(T)
  \]
\end{theorem}

\begin{proof}
    \Rightarrow: Assume $p ≤_m q$. Then there is a refinement relation $\mc R$.
      To show that for $(p,q) ∈ \mc R$ there is no closed tree from $(p,q)$, we
      show the contraposition for any $T$, that is if $T$ is closed, then $T_r ∉ R$.
     
      Recall that for any $T$ there is an attacking transition from $T_r$ and
      the edges correspond to the fitting defending transition.
%      For every Let $r$ be the attacking transition corresponding to $(p,q)$ in $T$.
%      For every fitting defending transition $r'$ to $(p',q')$ there is an edge
%      from $(p,q)$ to $(p',q')$.
      Further if $T$ is closed, we have $T_O = ∅$ and every $T' ∈ T_C$ is also closed.

      Now we show the proposition by induction over the number of subtrees
      $|subtrees(T)|$:
      \begin{enumerate}
        \item $|subtrees(T)| = 0$: Then there is an attacking transition and as
          $T_C = ∅$ there is no defending transition, therefore $(p,q) ∉ \mc R$.
        \item $|subtrees(T)| ≥ 1$:
          Then there is an attacking rule and for every defending transition leading
          to $(p',q')$, there is an edge to a closed tree $T'$ with $T'_r = (p',q')$.
          $T'$ is a proper subtree of $T$ and has less subtrees itself, so
          by induction hypothesis we have $(p',q') ∉ \mc R$ and therefore $(p,q) ∉ \mc R$.
      \end{enumerate}
    \Leftarrow: Assume that there is no closed attack tree $T$ with $T_r = (p,q)$.
      To show $p ≤_m q$, we show that
      $\mc R := \{ (p',q') \mid ¬∃ T : T_r = (p',q') ∧ closed(T) \}$ is a valid
      refinement relation with $(p,q) ∈ \mc R$.

      For any attacking transition and $(p,q) ∈ \mc R$,
      by inference rule 1 or 2 there exists an attacking tree $T$ with
      $T_r = (p,q)$.
      From all such $T$ with $T_r = (p,q)$, choose one where $T_O$ is minimal
      with regard to the inclusion order.
      There exists $(p',q') ∈ T_O$ with $(p',q') ∈ \mc R$, because otherwise
      there would be a closed attack tree $T'$ with $T'_r = (p',q')$ and
      by inference rule 3 we would get
      $T'' = (T_r, T_O ∖ \{p',q'\}, T_C ∪ \{T'\})$ with $T''_O = T_O ∖ \{(p',q')\} ⊊ T_O$
      in contradiction to the minimality of $O$.
      So for the attacking transition from $(p,q)$ there is a defending transition
      to $(p',q')$ with $(p',q') ∈ \mc R$.
\end{proof}

% tree used to decide refinement

\section{Visibly pushdown automaton}

% tree not computable

\begin{definition}[Visibly pushdown automaton]
A PRS $Δ$ over the action alphabet $Act$ is a
\emph{visibly pushdown automaton (vPDA)} if
there is a partition
$Act = Act_r \uplus Act_i \uplus Act_c$
such that every rule $(p, a, p') ∈ Δ$ has the form:
\begin{align*}
  p &= P⋅S
  & &\text{and} &
  p' &= \begin{cases}
  Q & \text{if } a ∈ Act_r \quad \text{(return rule)}\\
  Q⋅T & \text{if } a ∈ Act_i \quad \text{(internal rule)} \\
  Q⋅T⋅R & \text{if } a ∈ Act_c \quad \text{(call rule)}
\end{cases}
\end{align*}
A \emph{modal visibly pushdown automaton (mvPDA)} is then an
mPRS $(\Dmay, \Dmust)$ such that $\Dmay$ and $\Dmust$ are vPDA.
\end{definition}

For mvPDA we will define a relation similiar which allows us to represent
a parts of the attack tree for the corresponding MTS. These are attack rules.

\begin{definition}[Attack rule]
  An \emph{attack rule} is a tuple $((p,q), S)$ with $p,q ∈ \mc P$ and $S ⊆ \mc P$.
  It is written as $(p,q) \attack S$
  
  For an mvPDA $(\Dmay, \Dmust)$, the attack rules
  obtainable from the rewrite rules are given by:
  \begin{mathpar}
    \inferrule{(p, a, p') ∈ \Dmay}{(p,q) \attack \{ (p', q') \mid (q, a, q') ∈ \Dmay \}}
      \, (1) \\
    \inferrule{(q, a, q') ∈ \Dmust}{(p,q) \attack \{ (p', q') \mid (p, a, p') ∈ \Dmust \}}
      \, (2) \\
    \inferrule{(p,q) \attack \{(p',q')\} \uplus S \\ (p',q') \attack S' \\
      ∀(p'',q'') ∈ S' : |p''| = 1 }
      { (p,q) \attack S ∪ S'} \, (3) \\
    \inferrule{(p,q) \attack \{(p'⋅P,q'⋅Q)\} \uplus S \\ (p',q') \attack S' \\
      ∀(p'',q'') ∈ S' : |p''| = 1 }
      {(p,q) \attack S ∪ \{  (p''⋅P, q''⋅Q) \mid (p'',q'') ∈ S' \}} \, (4)
  \end{mathpar}

  Due to the constraints on the rewrite rules of an mvPDA and the construction of the
  attack rules, we can see that for any rule $(p,q) \attack S$, it holds that
  $|p| = |q| = 2$ and for any $(p',q') ∈ S$ that $1 ≤ |p'| = |q'| ≤ 3$.
  
  When the rules 3 and 4 always combine a rule $(p,q) \attack S \uplus \{(p',q')\}$
  and a rule $(p',q') \attack S'$ on right, it always holds that
  $|p'| = 2$ or $|p'|$ = 3 and for all $(p'',q'') ∈ S'$ $|p''| = 1$.
  We will call a rule $p \attack S$ a \emph{right-hand side} rule if
  $∀(p',q') ∈ S: |p'| = 1$ and otherwise a \emph{left-hand side} rule.
  This partitions the set of rules into two classes.
\end{definition}

\begin{lemma}
  \label{lemma:rule-lift}
  Given an MTS generated by a mvPDA,
  for $|p| ≥ 2$, $|q| ≥ 2$, $p,q$ sequential and any $s,t ∈ \mc P$:
\begin{align*}
  p \may[a] p' &\iff p⋅s \may[a] p'⋅s
  & &\text{and} &
  q \must[a] q' &\iff q⋅t \may[a] q'⋅t
\end{align*}
\end{lemma}
\begin{proof}
  \Rightarrow: Follows directly from the induction rules of an MTS from an mPRS.
  
  \Leftarrow: In the inference chain for $p⋅s \may[a] p'⋅s$,
  there is a $(r,a,r') ∈ \Dmay$ which was used to obtain that rule
  with $p⋅s = r⋅s'$ and $p'⋅s = r'⋅s'$. As $|r| ≤ |p|$, $|r'| ≤ |p'$ and $p,p',r,r'$ are all
  sequential, there is $s''$ with $p = r⋅s''$ and $p' = r⋅s''$.
  Then we can infer the transition $r⋅s'' \may[a] r'⋅s'' = p \may[a] p'$.
  As $|r| ≤ |p⋅s|$ and both $p$ and $r$ are sequential, we have $r = p$
  The same holds for $q⋅t \must q'⋅t$.
\end{proof}

\begin{corollary}
  \label{corollary:tree-lift}
  Given an MTS generated by a mvPDA,
  for $|p| ≥ 2$, $|q| ≥ 2$, $p,q$ sequential and any $s,t ∈ \mc P$:

  There is an attack tree $T$ with $T_r = (p,q)$
  exactly if there is an $R$ with $R_r = (p⋅s, q⋅t)$ and
  $open(R) = \{ (p'⋅s,q'⋅t) \mid (p', q') ∈ open(T) \}$.
\end{corollary}

\begin{definition}[Partition of an attack tree]
  A partition $P$ of an attack tree $T$ is given by a set
  of subtrees $P ⊆ subtree(T)$ with $T ∈ P$.

  For $R_1,R_2 ∈ P$, we define a partial ordering
  $R_1 ≤ R_2 \iff R_1 ∈ subtree(R_2)$ and consequently
  $R_1 < R_2 \iff R_1 ≤ R_2 ∧ R_1 ≠ R_2$.
  We define the partition successors of $R ∈ P$ given $P$ as
  $succ_P(R) = \{ R' ∈ P \mid R' < R ∧ ¬∃ R'' : R' < R'' ∧ R'' < R \}$.
  %As the subtree relation defines a partial ordering, TODO

%  A set of attack trees $P ⊆ \mc T$ is a \emph{partition} of
%  an attack tree $T$ if there is $R ∈ P$ with $R_r = T_r$
%  and for all $R ∈ P$:
%  \begin{enumerate} 
%    \item Either $R_r = T_r$, or $R_r ∈ open(R')$ for
%      some $R' ∈ P$.
%    \item For every open state $R' ∈ open(P)$: Either $R' ∈ open(T)$ or
%      $R' = R''$ for some $R'' ∈ P$.
%  \end{enumerate}
\end{definition}

\begin{definition}[Part represented by an attack rule]
  A subtree $R ∈ P$ in a partition
  is said to be \emph{represented} by an
  attack rule $(p,q) \attack S$ if there exist $s,t ∈ \mc P$
  such that $T_r = (p⋅s,q⋅t)$
  and $\{ R'_r \mid R' ∈ succ_P(R) \} = \{ (p'⋅s,q'⋅t) \mid (p',q') ∈ S \}$
\end{definition}

\begin{theorem}
  \label{theorem:tree-attack}
  For an mvPDA $(\Dmay, \Dmust)$ with its induced MTS $(\mc P, \may[], \must[])$,
  it holds that for any $P,S,Q,R ∈ Const$:
  \[
    ∃ T : T_r = (P⋅S,Q⋅R) ∧ closed(T) \iff (P⋅S,Q⋅T) \attack ∅
  \]
\end{theorem}
\begin{proof}
    \Rightarrow: Assume $T$ to be closed tree with $T_r = (P⋅S,Q⋅T)$.

      We show that if there is a $n$ rules $\{a_1, …, a_n\}$ such that
      there is a partition $\{R_1, …, R_n\}$ of $T$ with each $R_i$ being
      represented by $a_i$, then there is a rule representing $T$.

      We show that by induction on $n$:
      
      \begin{enumerate}
        \item $n = 1$: Then $R_1 = T$ and $a_1$ represents $T$.
        \item $n > 1$:
          Let $R_1$ be the subtree with $R_r = (P⋅S, Q⋅T)$
          
          As $n > 1$, there is $R' ∈ succ_P(R)$ with $R'_r = (p',q')$.
          Then for $a_1 = (P⋅S,Q⋅T) \attack S$ we have by representation
          $R'_r ∈ S$.
          
          We have $|p'| = |q'| ≥ 2$, as otherwise
          there would be no rule applicable from that state and therefore $R'$ would not exist.
          So $a_1$ is a left-hand side rule.

          For every subtree $R ∈ P$ with $succ_P(R) = ∅$,
          we have $a_i = (p,q) \rightarrow ∅$, so that is a right-hand side rule.
          Every path in $T$ eventually leads to such a subtree.

          Then by following the successors of the subtrees from $R_1$, we will eventually
          come to a subtree $R$ succeded by a subtree $S$ such that
          $b_i$ is a left-hand side rule and $b_j$ is a right-hand side rule.

          %As $S ∈ succ_P(R)$,
          %by lemma \ref{lemma:tree-composition}
          %we get a tree $R_0$ with $root(R_0) = root(R)$ and
          %$open(R_0) = open(R) ∖ \{ root(S) \} ∪ open(S)$.
          The partition $P' = P ∖ \{S\}$ then is again a partition of $T$
          where $succ_{P'}(R) = succ_P(R) ∖ \{S\} ∪ succ_P(S)$ and
          other successors are unchanged.
          We now show that we can construct a rule representing $R_0$:

          Let $b_i = (p,q) \attack S$ and $b_j = (p',q') \attack S'$.
          By the representation of $b_i$ for $R$ and
          $S_r ∈ \{ R'_r \| R' ∈ succ_P(R) \}$,
          there is $s,t ∈ \mc P$ and $(p'',q'') ∈ S$ with $S_r = (p''⋅s,q''⋅t)$.
          By the representation of $b_j$ for $S$,
          there is $s',t' ∈ \mc P$ with $S_r = (p'⋅s',q'⋅t')$.

          Then $(p''⋅s,q''⋅t) = (p'⋅s',q'⋅t')$.
          As $2 ≤ |p''| = |q''| ≤ 3$ and $|p'| = |q'| = 2$ either
          $s = s'$ and $t = t'$ or $P⋅s = s'$ and $Q⋅t = t'$ for some $P,Q ∈ Const$.
          
          In the first case, $(p',q') = (p'',q'')$, and we can apply rule 3 to obtain
          $(p,q) \attack S \{(p'',q'')\} ∪ S'$.
          With $\{ (p'⋅s,q'⋅t) \mid (p',q') ∈ S ∖ \{(p'',q'')\} ∪ S' \} = succ_{P'}(R)$,
          it represents $R$ in $P'$.

          In the second case, $(p'⋅P,q') = (p'',q'')$, and we can apply rule 4 to obtain
          $(p,q) \attack S ∪ \{  (p''⋅P, q''⋅Q) \mid (p'',q'') ∈ S' \}$
          With $\{ (p'⋅s,q'⋅t) \mid (p',q') ∈ S ∖ \{(p'',q'')\} \}$
          $∪ \{ (p''⋅P⋅s,q''⋅Q⋅t) \mid (p'',q'') ∈ S' \} = succ_{P'}(P_i)$,
          it represents $R$ in $P'$.

          Then as $P'$ is a partition for $T$ having a rule representing each part
          with $n - 1$ element, we can apply the induction hypothesis and obtain
          a rule representing $T$.
      \end{enumerate}

      Now we need to show there is a partition represented by attack rules.
      If we initially take $P = subtrees(T)$, for each
      $R ∈ P$ we have:
      There is an attacking transition from $R_r$ which induced $R$.
      As $succ_P(R) = R_C$, for each $R' ∈ succ_P(R)$
      there is a fitting defending transition to $R'_r$ and vice-versa.
      If $p⋅s \may[a] p'⋅s$ was induced by $(p, a, p') ∈ \Dmay$ and
      each $q⋅t \may[a] q'⋅t$ was induced by $(q, a, q') ∈ \Dmay$, then
      $(p,q) \attack \{ (p',q') \mid (q, a, q') \}$ represents R % TODO

      Finally for a rule $(p,q) \attack S$ representing
      the closed tree $T$ with $T_r = (P⋅S,Q⋅T)$, necessarily
      $(p,q) = (P⋅S,Q⋅T)$ and $S = ∅$.

    \Leftarrow:
      We show that if $(p,q) \attack S$, then there is a tree
      $T$ with $T_r = (p,q)$ such that $open(T) = S$
      by induction on the construction of $(p,q) \attack S$:
      \begin{enumerate}
        \item It was constructed by rule 1 from $(p, a, p') ∈ \Dmay$. Then there is
          an attacking transition $p \may[a] p'$ and 
          for every $(q, a, q') ∈ \Dmay$ there is an induced defending transition
          $q \may[a] q'$.
          Then $S = \{ (p',q') | q \may[a] q' \}$ and by attack tree inference rule 1
          there is $T = ((p, q), S, ∅)$ with $open(T) = S$.
        \item It was constructed by rule 2 from $(q, a, q') ∈ \Dmust$. Then there is
          an attacking transition $q \must[a] q'$ and 
          for every $(p, a, p') ∈ \Dmay$ there is an induced defending transition
          $p \must[a] p'$.
          Then $S = \{ (p',q') | p \may[a] p' \}$ and by attack tree inference rule 2
          there is $T = ((p, q), S, ∅)$ with $open(T) = S$.
        \item It was constructed by rule 3 from
          $(p,q) \attack \{(p'⋅P,q'⋅Q)\} \uplus S''$ and
          $(p',q') \attack S'$ with $S = S'' ∪ S'''$ and
          $S''' = \{  (p''⋅P, q''⋅Q) \mid (p'',q'') ∈ S' \}$.
          Then by induction hypothesis there is
          a tree $T'$ with $T'_r = (p',q')$ and $open(T') = S'$ and
          a tree $T''$ with $T''_r = (p,q)$ and $open(T'') = S'' \uplus \{(p'⋅P,q'⋅Q)\}$.
          By applying lemma \ref{corollary:tree-lift} on $T'$ there is a tree
          $T'''$ with $T'''_r = (p'⋅P,q'⋅Q)$,
          $open(T''') = O''' \uplus \{(p'⋅P,q'⋅Q)\}$ and
          $O''' = \{ (p''⋅P, q''⋅Q) \mid (p'',q'') ∈ S' \} = S'''$.
          By applying lemma \ref{lemma:tree-composition} on $T''$ and $T'''$ there is
          a tree $T$ with $T_r = (p,q)$ and $open(T) = S'' ∪ S''' = S$.
        \item It was constructed by rule 4 from
          $(p,q) \attack S'' \uplus \{(p',q')\} $ and
          $(p',q') \attack S'$ with $S = S'' ∪ S'$.
          Then by induction hypothesis there is
          a tree $T'$ with $T'_r = (p',q')$ and $open(T') = S'$ and
          a tree $T''$ with $T''_r = (p,q)$ and $open(T'') = S'' \uplus \{(p',q')\}$.
          By applying lemma \ref{lemma:tree-composition} on $T'$ and $T''$ there is
          a tree $T$ with $T_r = (p,q)$ with $open(T) = S'' ∪ S' = S$.
      \end{enumerate}
      Therefore if $(P⋅S,Q⋅T) \attack ∅$, then there is a tree
      $T$ with $T_r = (P⋅S,Q⋅T)$ and $open(T) = ∅$.
\end{proof}

% theory and background

