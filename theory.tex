\chapter{Theory}

\section{Processes}

%TODO
Processes are used to describe the state of many sequential or concurrent systems.
The syntax here is taken from \cite{Mayr00} and \cite{Esparza01}.

% processes are parallel or sequential

\begin{definition}[Process]
The set of \emph{processes} $\mc P$ over a set of constants $Const$ is given by
\begin{mathpar}
  \inferrule{ }{ε ∈ \mc P}\, (0) \hspace{1cm}
  \inferrule{X ∈ Const}{X ∈ \mc P}\, (1) \hspace{1cm}
  \inferrule{p ∈ \mc P \\ q ∈ \mc P}{p⋅q ∈ \mc P}\, (S) \hspace{1cm}
  \inferrule{p ∈ \mc P \\ q ∈ \mc P}{p\|q ∈ \mc P}\, (P)
\end{mathpar}
where $ε$ is the empty process, $X ∈ C$ are process constants,
$⋅$ means sequential composition and
$\|$ means parallel composition. 

Processes are considered equivalent under the smallest congruence relation
such that the operator $⋅$ is associative,
$\|$ is associative and commutative and
$ε$ is a unit for both $⋅$ and $\|$.

From here on we will denote processes by lowercase letters $p,q,…$ and single
process constants by uppercase letters $P,Q,…$.
\end{definition}

The class of processes that can be produced just with rule 1,
i.e. contain no $\|$ or $⋅$ and are not the empty process,
is the class of \emph{constant processes} \textbf{1}.
The class of processes that can be produced just with rule 0, 1 and S, i.e. contain no $\|$,
is the class of \emph{sequential processes} \textbf{S}.
The class of processes that can be produced just with rule 0, 1 and P, i.e. contain no $⋅$,
is the class of \emph{parallel processes} \textbf{P}.
The class of processes that can be produced by any combination of rules is the class
of \emph{general processes} \textbf{G}.
% TODO add constant or general processes?

\begin{definition}[Size of a process]
  The \emph{size} $|p|$ of a process $p$,
  is defined by
  \begin{align*}
    |ε| &= 0 \\
    |X| &= 1 \\
    |p⋅q| &= |p| + |q| \\
    |p \| q| &= |p| + |q|
  \end{align*}
  which is the number of constants appearing in the term.
\end{definition}

\section{Modal transition system}

Modal transitions systems \cite{LarsenT88, BenesKLS09, BenesK12} extend
labelled transition system with two types of transitions, may and must transitions.
The idea is that a refinement of system must keep any must transitions,
while it may only have may transitions present in the original system.

\begin{definition}[Modal transition system]
A \emph{modal transition system (MTS)} over an action alphabet $Act$ is
a triple $(\mc P, \may[], \must[])$ where $\mc P$ is a set of processes and
$\must[] ⊆ \may[] ⊆ \mc P × Act × \mc P$.
An element $(p,a,q) ∈ \may[]$ is a \emph{may transition}, written as $p \may[a] q$,
and an element $(p,a,q) ∈ \must[]$ is a \emph{must transition}, written as $p \must[a] q$.
\end{definition}

\section{Modal refinement}

For two processes of an MTS, we want to define modal refinement as a 
as an extension of bisimulation.
One process refines another process if it a more specific version of
a more general process.
Both processes should match each others actions, except that the more
general process can execute necessary must transitions and the more
specific process can execute possible may transitions.

Out of simplicity, we regard only modal refinment for two processes from a single MTS.
Modal refinement of processes from two different MTS can be reduced to this by taking
the disjoint union of the MTS.

\begin{definition}[Refinement]
  Let $(\mc P, \may, \must)$ be an MTS and $p,q ∈ \mc P$ be processes.
  We say that $p$ \emph{refines} $q$, written $p ≤_m q$, if there is a relation
  $\mc R ⊆ \mc P × \mc P $ such that
  $(p, q) ∈ \mc R$ and for every $(p, q) ∈ \mc R$ and every $a ∈ Act$:
  \begin{enumerate}
    \item If $p \may[a] p'$ then there is a transition $q \may[a] q'$ s.t.
          $(p',q') ∈ \mc R$.
    \item If $q \must[a] q'$ then there is a transition $p \must[a] p'$ s.t.
          $(p',q') ∈ \mc R$.
  \end{enumerate}
  Modal refinement can also be seen as a refinement game from a pair of processes
  $(p,q)$ where each side plays an attacking transition and the other a defending transition
  to reach a new state.

  Thus if from the state $(p,q)$ there is a transition $p \may[a] p'$ or $q \may[a] q'$,
  we will call this an \emph{attacking transition} and a transition
  $q \may[a] q'$ or $p \must[a] p'$ from that state matching the type and action of
  the attacking transition a \emph{defending transition}.
  
  Then $p ≤_m q$ holds if there no winning strategy from $(p,q)$, i.e.
  a sequence of attacking transitions such that for every choice of defending transition
  we will reach a state $(p',q')$ from which there is an attacking transition but no
  defending transition.
\end{definition}

\section{Modal process rewrite system}

A modal process rewrite system is a framework
for defining a modal transition system by a finite set of rules.
They are a straightforward extension of process rewrite systems,
which can be used to model many transition systems such as
pushdown automaton or Petri nets \cite{Mayr00, Esparza01}.

\begin{definition}[Modal process rewrite system]
A \emph{process rewrite system (PRS)} over an action alphabet $Act$
is a finite relation $Δ ⊆ \mc P ∖ \{ε\} × Act × \mc P$.
Elements of $Δ$ are called \emph{rewrite rules}.
A \emph{modal process rewrite system (mPRS)} is a tuple $(\Dmay, \Dmust)$ where
$\Dmay, \Dmust$ are process rewrite systems such that $\Dmay ⊆ \Dmust$.

An mPRS $(\Dmay, \Dmust)$ induces an MTS $(\mc P, \may[], \must[])$ as follows:
\begin{mathpar}
  \inferrule{(p, a, p') ∈ \Dmay}{p \may[a] p'} \, (1) \quad
  \inferrule{(p, a, p') ∈ \Dmust}{p \must[a] p'} \, (2) \\
  \inferrule{p \may[a] p'}{p⋅q \may[a] p⋅q} \, (3) \quad
  \inferrule{p \must[a] p'}{p⋅q \must[a] p'⋅q} \, (4) \quad
  \inferrule{p \may[a] p'}{p\|q \may[a] p\|q} \, (5) \quad
  \inferrule{p \must[a] p'}{p\|q \must[a] p'\|q} \, (6)
\end{mathpar}
\end{definition}

\section{Visibly pushdown automaton}

One subclass of PRS are pushdown automata (PDA).
Already for its subclass of basic process
algebras (BPA) simulation is undecidable \cite{GrooteH94} and
therefore also refinement.
For the subclass of visibly PDA however,
most problems are decidable and its class of languages
is closed under all desirable operations \cite{AlurM04}.
Especially refinement on its modal extension is decidable, as
shown in \cite{BenesK12}.

% tree not computable

\begin{definition}[Visibly pushdown automaton]
A PRS $Δ$ over the action alphabet $Act$ is a
\emph{visibly pushdown automaton (vPDA)} if
there is a partition
$Act = Act_r \uplus Act_i \uplus Act_c$
such that every rule $(p, a, p') ∈ Δ$ has the form
\begin{align*}
  p &= P⋅S
  & &\text{and} &
  p' &= \begin{cases}
  Q & \text{if } a ∈ Act_r \quad \text{(return rule)}\\
  Q⋅T & \text{if } a ∈ Act_i \quad \text{(internal rule)} \\
  Q⋅T⋅R & \text{if } a ∈ Act_c \quad \text{(call rule)}
\end{cases}
\end{align*}
for some $P,Q,S,T,R ∈ Const$.
A \emph{modal visibly pushdown automaton (mvPDA)} is an
mPRS $(\Dmay, \Dmust)$ such that $\Dmay$ and $\Dmust$ are vPDA.
\end{definition}

We will have a look at the concepts introduced so far in an example.

\begin{example}[mvPDA]
  Suppose we want to create a specification for a vending machine selling coffee.
  It may accept any number of coins, but once it does,
  it nondeterministically chooses coffee or tea and must offer one
  beverage for each coin inserted.
  It may also offer the other beverage, but is not required to.

  An implementation of this specifiation wants to avoid nondeterminism
  and only chooses tea or coffee once the first choice is made. After that
  it only offers the chosen beverage until there are no more coins.

  Figure \ref{fig:vending-mvpda} shows both implementation and specification modeled by
  an mvPDA. Note that may transitions are implied by the must transitions.
  The process $P⋅S$ is the initial process for the implementation,
  which stores the coin count as the number of symbols $M$ on the stack and the
  beverage choice as the state $T$ or $C$.
  The process $Q⋅S$ is the initial process for the specification, which stores the count
  of coins as the number of $T$ or $C$ on the stack and the beverage choice
  as the stack symbol chosen.
\end{example}

\begin{figure}[ht]
  \centering
  \begin{minipage}[b]{.45\textwidth}
    \begin{align*}
      P⋅S &\must[coin] P⋅M⋅S \\
      P⋅M &\must[coin] P⋅M⋅M \\
      C⋅S &\must[coin] P⋅M⋅S \\
      T⋅S &\must[coin] P⋅M⋅S \\
      P⋅M &\must[tea] T \\
      P⋅M &\must[coffee] C \\
      T⋅M &\must[tea] T \\
      C⋅M &\must[coffee] C
    \end{align*}
  \end{minipage}\quad
  \begin{minipage}[b]{.45\textwidth}
    \begin{align*}
      Q⋅S &\may[coin] Q⋅T⋅S \\
      Q⋅S &\may[coin] Q⋅C⋅S \\
      Q⋅T &\may[coin] Q⋅T⋅T \\
      Q⋅C &\may[coin] Q⋅C⋅C \\
      Q⋅T &\must[tea] Q \\
      Q⋅T &\may[coffee] Q \\
      Q⋅C &\may[tea] Q \\
      Q⋅C &\must[coffee] Q
    \end{align*}
  \end{minipage}
  \caption{Vending machine mvPDA}
  \label{fig:vending-mvpda}
\end{figure}
  
\begin{example}[Refinement]
  We can regard some refinement problems on the mvPDA from figure \ref{fig:vending-mvpda}.
  For example, we can show $T⋅M ≤_m Q⋅T$ holds.
  From $T⋅M$ the only may transition possible is $T⋅M \may[tea] T$, which is answered
  by $Q⋅T \may[tea] Q$. From $Q⋅T$ the only must transition is $Q⋅T \must[tea] Q$,
  which is answered by $T⋅M \must[tea] T$. In both cases from the resulting state
  $(T,Q)$ there are no more transitions, $T⋅M ≤_m Q⋅T$.

  On the other hand, $C⋅M ≤_m Q⋅T$ does not hold, as from $Q⋅T$ there is the transition
  $Q⋅T \may[tea] T$, but there is no transition of the form $C⋅M \may[tea] p'$.

  The main problem is to decide whether $P⋅S ≤_m Q⋅S$ holds. It is not easy to see
  if it does from the rules directly.
  However later we will construct a method to decide it algorithmically
  and show that it actually does not hold.
\end{example}

\section{Attack tree}

When regarding refinement as a game, we can represent the winning strategy
in a tree. Here we will define attack trees as a representation of partially
or fully explored strategies, which can then be used to decide refinement.

\begin{definition}[Attack tree]

  An \emph{attack tree} over a set of processes $\mc P$ is a rooted tree where
  each node has two kinds of children.
  It is given by a triple $((p,q),O,C)$,
  representing the tree with the root node labeled by $(p,q) ∈ \mc P^2$,
  the set of open edges $O$ leading to states $(p',q') ∈ \mc P^2$ and
  the set of closed edges $C$ leading to the attack trees that are children of the
  root node.
  
  For an attack tree $T = ((p,q),O,C)$, we will use the short notations
  $T_r = (p,q)$ for the root, $T_O = O$ for the set of states open edges lead to
  and $T_C = C$ for the set of child trees closed edges lead to.
  
  The set of attack trees $\mc T$ constructable from an MTS $(\mc P, \may, \must)$
  are defined inductively by:
  \begin{mathpar}
    \inferrule{p,q ∈ \mc P, p \may[a] p'}
      {((p,q), \{ (p', q') \mid q \may[a] q' \}, ∅) ∈ \mc T}
    \, (1) \\
    \inferrule{p,q ∈ \mc P, q \must[a] q'}
      {((p,q), \{ (p', q') \mid p \must[a] q' \}, ∅) ∈ \mc T}
    \, (2) \\
    \inferrule{T ∈ \mc T \\ R ∈ \mc T \\ R_r ∈ T_O}
      {(T_r, T_O ∖ \{R_r\}, T_C ∪ \{R\}) ∈ \mc T}
    \, (3) \\
  \end{mathpar}
  
  Rules 1 and 2 specify an initial tree for an attacking transition with edges to
  states for each possible defensive transitions,
  while rule 3 replaces an open edge to a state with a tree with that state as its
  root.

  As we can see from the construction rules, every tree
  has a corresponding attacking transition from the root node, while for each defending transition
  applicable from that state and attacking transition there is an edge to either an open state or
  a child tree. Therefore we can identify nodes with attacking transitions and edges with
  defending transitions.

  Any attack tree has finite depth, so wan define
  the set of all \emph{subtrees} of $T$, including $T$ itself, recursively by
  $subtree(T) = T ∪ \left(⋃_{T' ∈ T_C} subtree(T') \right)$.
  
  The set of all \emph{open states} of $T$ are the states $(p',q')$ that
  have an open edge to it, that is $open(T) = ⋃_{T' ∈ subtree(T)} T'_O$
  or equivalently $open(T) = T_O ∪ \left(⋃_{T' ∈ T_C} open(T') \right)$.
  
  We say that a tree is \emph{closed} if it has no open states, that is
  $closed(T) \iff open(T) = ∅$.
\end{definition}

The construction rules for attack trees only allow us to add a tree
to the root node as a subtree if there is an open edge.
However, the following lemma shows that we can replace any open edge
in the tree by an appropriate tree.

\begin{lemma}[Tree composition]
  \label{lemma:tree-composition}
  If there are attack trees $T$ and $R$ with
  $R_r ∈ open(T)$,
  then there is an attack tree $S$ with
  $S_r = T_r$ and
  $open(S) = open(T) ∖ \{R_r\} ∪ open(R)$.
  and $s ∈ T_O$
\end{lemma}
\begin{proof}
  We prove the proposition by induction on the number of proper subtrees
  with an open edge to $R_r$, that is
  $n = |\{ T' ∈ subtree(T) \mid T' ≠ T ∧ R_r ∈ open(T')\}|$:
  \begin{enumerate}
    \item $n = 0$:
      Then $R_r ∈ T_O$ and $R_r ∉ open(T')$ for $T' ∈ T_C$,
      so with rule 3 we can construct
      $S = (T_r, T_O ∖ \{R_r\}, T_C ∪ \{R\})$ with
      $open(S) = open(T) ∖ \{R_r\} ∪ open(R)$
    \item $n ≥ 1$:
      Then there is $T' ∈ T_C$ such that $R_r ∈ open(T')$.
      $T'$ at least does not have itself as a proper subtree
      with an open edge to $R_r$, so we can apply
      the induction hypothesis to obtain
      $S'$ with $S'_r = T'_r$ and
      $open(S') = open(T') ∖ \{R_r\} ∪ open(R)$

      As $T'$ was added to $T_C$ some point in the construction of $T$,
      we can substitute $T'$ with $S'$ and obtain
      $T''$ with $T''_r = T_r$, $T''_O = T_O$ and
      $T''_C = T_C ∖ \{T'\} ∪ \{S'\}$.
      We have $open(T'') = T_O ∪ \left(⋃_{R' ∈ T_C ∖ \{T'\} } open(R')\right) ∪ open(S')$.

      If $R_r ≠ open(T'')$, then $open(T'') = open(T) ∖ \{R_r\} ∪ open(R)$ and we are done.
      Otherwise $T''$ has less subtrees with an open edge to
      $R_r$, therefore we
      can apply the induction hypothesis on it to obtain
      $S$ with $S_r = T_r$ and
      $open(S) = open(T'') ∖ \{R_r\} ∪ open(R) = open(T) ∖ \{R_r\} ∪ open(R)$.
  \end{enumerate}
\end{proof}

The following theorem gives us the equivalence of closed trees
and non-refining processes. With that result, we can
use the attack tree structure to argue over refinement instead
of the refinement relation.

\begin{theorem}[Attack tree refinement]
  \label{theorem:refinement-tree}
  For an MTS $(\mc P, \may, \must)$ and processes $p,q ∈ \mc P$:
  \[
    (p ≤_m q) \iff ¬∃ T ∈ \mc T : T_r = (p,q) ∧ closed(T)
  \]
\end{theorem}

\begin{proof}
    \Rightarrow: Assume $p ≤_m q$. Then there is a refinement relation $\mc R$.
      To show that for $(p,q) ∈ \mc R$ there is no closed tree from $(p,q)$, we
      show the contraposition that for any $T ∈ \mc T$, if $T$ is closed, then $T_r ∉ R$.
     
      Recall that for any $T$ there is an attacking transition from $T_r$ and
      the edges correspond to the appropriate defending transition.
      Further if $T$ is closed, we have $T_O = ∅$ and every $T' ∈ T_C$ is also closed.

      Now we show the contraposition by induction over the number of subtrees
      of $T$, that is $n = |subtrees(T)|$:
      \begin{enumerate}
        \item $n = 1$: Then there is an attacking transition and as
          $T_C = ∅$ there is no defending transition, therefore $(p,q) ∉ \mc R$.
        \item $n > 1$:
          Then there is an attacking transition and for every defending transition leading
          to $(p',q')$, there is an edge to a closed tree $T'$ with $T'_r = (p',q')$.
          $T'$ is a proper subtree of $T$ and has less subtrees itself, so
          by induction hypothesis we have $(p',q') ∉ \mc R$ and therefore $(p,q) ∉ \mc R$.
      \end{enumerate}
    \Leftarrow: Assume that there is no closed attack tree $T$ with $T_r = (p,q)$.
      To show $p ≤_m q$, we show that
      $\mc R := \{ (p',q') \mid ¬∃ T : T_r = (p',q') ∧ closed(T) \}$ is a valid
      refinement relation with $(p,q) ∈ \mc R$.

      For any attacking transition and $(p,q) ∈ \mc R$,
      by inference rule 1 or 2 there exists an attacking tree $T$ with
      $T_r = (p,q)$.
      From all such $T$, choose one where $open(T)$ is minimal
      with regard to the inclusion order.
      There exists $(p',q') ∈ open(T)$ with $(p',q') ∈ \mc R$, because otherwise
      there would be a closed attack tree $T'$ with $T'_r = (p',q')$ and
      with lemma \ref{lemma:tree-composition} we would get $T''$
      with $T''_r = T_r$ and $open(T'') = open(T) ∖ \{(p',q')\} ⊊ open(T)$
      in contradiction to the minimality of $open(T)$.
      So for the attacking transition from $(p,q)$ there is a defending transition
      to $(p',q')$ with $(p',q') ∈ \mc R$.
\end{proof}

\begin{example}
  For the MTS induced by the vending machine mvPDA from figure \ref{fig:vending-mvpda},
  attack trees for some states are displayed in figure \ref{fig:vending-attack-trees}.
  Tree nodes are displayed in rectangles with their associated attacking transition
  below them, edges are labeled with their defending transitions and
  open states are shown in rectangles with rounded corners.

  These trees can be combined to form a closed tree shown in figure
  \ref{fig:vending-combined-attack-tree}.
  With theorem \ref{theorem:refinement-tree}, this shows that
  $P⋅S ≤_m Q⋅S$ does not hold. A winning strategy 
  can be read of the tree.
\end{example}

\begin{figure}[ht]
  \centering
\begin{tikzpicture}[
  level 1/.style={level distance=9cm, sibling distance=2cm},
  edge from parent path={(\tikzparentnode.east) -- (\tikzchildnode.west)},
]
  \node (T1) {$(P⋅S,Q⋅S)$}
    child {
        node[openstate] {$(P⋅M⋅S,Q⋅C⋅S)$}
        edge from parent
        node[defense] {$Q⋅S \may[coin] Q⋅C⋅S $}
    }
    child {
        node[openstate] {$(P⋅M⋅S,Q⋅T⋅S)$}
        edge from parent
        node[defense] {$Q⋅S \may[coin] Q⋅T⋅S $}
    }
  ;
  \node[attack, below of=T1] {$P⋅S \may[coin] P⋅M⋅S $};
  \node[label, left of=T1] {$T_1$:};

  \node[state, below of=T1, node distance=3cm] (T2) {$(P⋅M⋅S,Q⋅T⋅S)$}
    child {
      node[openstate] {$(P⋅M⋅M⋅S,Q⋅T⋅T⋅S)$}
      edge from parent
      node[defense] {$Q⋅T \may[coin] Q⋅T⋅T $}
    }
  ;
  \node[attack, below of=T2] {$P⋅M \may[coin] P⋅M⋅M $};
  \node[label, left of=T2] {$T_2$:};

  \node[state, below of=T2, node distance=2cm] (T3) {$(P⋅M⋅S,Q⋅C⋅S)$}
    child {
      node[openstate] {$(P⋅M⋅M⋅S,Q⋅C⋅C⋅S)$}
      edge from parent
      node[defense] {$Q⋅C \may[coin] Q⋅C⋅C $}
    }
  ;
  \node[attack, below of=T3] {$P⋅M \may[coin] P⋅M⋅M $};
  \node[label, left of=T3] {$T_3$:};

  \node[state, below of=T3, node distance=2cm] (T4) {$(P⋅M⋅M⋅S,Q⋅T⋅T⋅S)$}
    child {
      node[openstate] {$(T⋅M⋅S,Q⋅T⋅S)$}
      edge from parent
      node[defense] {$Q⋅T \may[coffee] Q $}
    }
  ;
  \node[attack, below of=T4] {$P⋅M \may[coffee] T $};
  \node[label, left of=T4] {$T_4$:};

  \node[state, below of=T4, node distance=2cm] (T5) {$(P⋅M⋅M⋅S,Q⋅C⋅C⋅S)$}
    child {
      node[openstate] {$(T⋅M⋅S,Q⋅C⋅S)$}
      edge from parent
      node[defense] {$Q⋅C \may[tea] Q $}
    }
  ;
  \node[attack, below of=T5] {$P⋅M \may[tea] T $};
  \node[label, left of=T5] {$T_5$:};
  
  \node[state, below of=T5, node distance=2cm] (T6) {$(T⋅M⋅S,Q⋅T⋅S)$};
  \node[attack, below of=T6] {$Q⋅C \must[tea] Q $};
  \node[label, left of=T6] {$T_6$:};
  
  \node[state, right of=T6, node distance=9cm] (T7) {$(T⋅M⋅S,Q⋅C⋅S)$};
  \node[attack, below of=T7] {$Q⋅C \must[coffee] Q $};
  \node[label, left of=T7] {$T_7$:};
\end{tikzpicture}
  \caption{Initial attack trees for the vending machine MTS}
  \label{fig:vending-attack-trees}
\end{figure}

\begin{figure}[ht]
  \centering
\begin{tikzpicture}[
  level 1/.style={level distance=4cm, sibling distance=3.5cm},
  level 2/.style={level distance=4cm, sibling distance=2cm},
  level 3/.style={level distance=4cm, sibling distance=2cm},
  edge from parent path={(\tikzparentnode.east) -- (\tikzchildnode.west)},
]
\node {$T_1$}
    child {
        node {$T_3$}
        child {
          node {$T_5$}
          child {
            node {$T_7$}
          }
        }
    }
    child {
        node {$T_2$}
        child {
          node {$T_4$}
          child {
            node {$T_6$}
          }
        }
    }
    ;
\end{tikzpicture}
  \caption{Combined attack tree for the vending machine MTS}
  \label{fig:vending-combined-attack-tree}
\end{figure}

\section{Attack rule}

The attack trees we represent strategies for any MTS.
However, their states can be arbitrarily large and there
can is an infinite number of possible trees starting at a certain state.
We would to define a similiar concept for mvPDA, called attack rules,
which can be used to represent parts of an attack tree for the corresponding MTS.

\begin{definition}[Attack rule]
  An \emph{attack rule} is a tuple $((p,q), S)$ with $p,q ∈ \mc P$ and $S ⊆ \mc P$.
  It is written as $(p,q) \attack S$
  
  For an mvPDA $(\Dmay, \Dmust)$, the attack rules
  obtainable from the rewrite rules are given by:
  \begin{mathpar}
    \inferrule{(p, a, p') ∈ \Dmay}{(p,q) \attack \{ (p', q') \mid (q, a, q') ∈ \Dmay \}}
      \, (1) \\
    \inferrule{(q, a, q') ∈ \Dmust}{(p,q) \attack \{ (p', q') \mid (p, a, p') ∈ \Dmust \}}
      \, (2) \\
    \inferrule{(p,q) \attack S \uplus \{(p',q')\} \\ (p',q') \attack S' \\
      ∀(p'',q'') ∈ S' : |p''| = 1 }
      { (p,q) \attack S ∪ S'} \, (3) \\
    \inferrule{(p,q) \attack S \uplus \{(p'⋅P,q'⋅Q)\} \\ (p',q') \attack S' \\
      ∀(p'',q'') ∈ S' : |p''| = 1 }
      {(p,q) \attack S ∪ \{  (p''⋅P, q''⋅Q) \mid (p'',q'') ∈ S' \}} \, (4)
  \end{mathpar}

  Due to the constraints on the rewrite rules of an mvPDA and the construction of the
  attack rules, we can see that for any rule $(p,q) \attack S$, it holds that
  $|p| = |q| = 2$ and for all $(p',q') ∈ S$ that $1 ≤ |p'| = |q'| ≤ 3$.
  
  When the rules 3 and 4 combine a rule $(p,q) \attack S \uplus \{(p',q')\}$
  and a rule $(p',q') \attack S'$ on right, it always holds that
  $|p'| = 2$ or $|p'|$ = 3 and for all $(p'',q'') ∈ S'$ $|p''| = 1$.
  We will call a rule $p \attack S$ a \emph{right-hand side} rule if
  $∀(p',q') ∈ S: |p'| = 1$ and otherwise a \emph{left-hand side} rule.
  This partitions the set of rules into two classes.
\end{definition}

As the number of rules for an mvPDA is finite and all attack rules
produce states with processes of a bounded size, we see that
the set of all attack rules is finite.
We will use this and the inductive nature of the rules to develop
the algorithm to decide refinement later.

First we need to prove that attack rules can be used to obtain
attack trees.
As rewrite rules and attack rules only consist of processes of fixed
size and transitions and attack trees consist of processes of
arbitrary size, we need to have a mapping between them.
This is possible for mvPDA, as they only
defines rules from sequential processes with a fixed size,
and the MTS rules only induce bigger processes.

\begin{lemma}
  \label{lemma:rule-lift}
  Given an MTS generated by a mvPDA,
  for $|p| ≥ 2$, $|q| ≥ 2$, $p,q$ sequential and any $s,t ∈ \mc P$:
\begin{align*}
  p \may[a] p' &\iff p⋅s \may[a] p'⋅s
  & &\text{and} &
  q \must[a] q' &\iff q⋅t \must[a] q'⋅t
\end{align*}
\end{lemma}
\begin{proof}
  \Rightarrow: Follows directly from the induction rules of an MTS from an mPRS.
  
  \Leftarrow: In the inference chain for $p⋅s \may[a] p'⋅s$,
  there is a $(r,a,r') ∈ \Dmay$ which was used to obtain that rule
  with $p⋅s = r⋅s'$ and $p'⋅s = r'⋅s'$. As $|r| ≤ |p|$, $|r'| ≤ |p'$ and $p,p',r,r'$ are all
  sequential, there is $s''$ with $p = r⋅s''$ and $p' = r⋅s''$.
  Then we can infer the transition $r⋅s'' \may[a] r'⋅s'' = p \may[a] p'$.
\end{proof}

Consequently, we can apply this to attack trees to extend their states
with processes.

\begin{lemma}
  \label{lemma:tree-lift}
  Given an MTS generated by a mvPDA and any $s,t ∈ \mc P$:

  If there is an attack tree $T$ with $T_r = (p,q)$,
  then there is an attack tree $R$ with $R_r = (p⋅s, q⋅t)$ and
  $open(R) = \{ (p'⋅s,q'⋅t) \mid (p', q') ∈ open(T) \}$.
\end{lemma}
\begin{proof}
  If we have a tree $T$, we can apply lemma \ref{lemma:rule-lift}
  on each rule which generated the tree and obtain $R$.
\end{proof}

While our attack rules are not powerful enough to represent any
attack tree, they can represent certain parts.
A part of a tree is essentially
a node with all edges and nodes to a set of ancestors,
while a partition is a disjunct union of parts resulting
in the complete tree.
%TODO correct?

\begin{definition}[Partition of an attack tree]
  A partition $P$ of an attack tree $T$ is given by a set
  of subtrees $P ⊆ subtree(T)$ with $T ∈ P$.

  For $R_1,R_2 ∈ P$, we define a partial ordering
  $R_1 ≤ R_2 \iff R_1 ∈ subtree(R_2)$ and consequently
  $R_1 < R_2 \iff R_1 ≤ R_2 ∧ R_1 ≠ R_2$.
  We define the partition successors of $R ∈ P$ given $P$ as
  $succ_P(R) = \{ R' ∈ P \mid R' < R ∧ ¬∃ R'' : R' < R'' ∧ R'' < R \}$.
\end{definition}

A rule should than correspond to a part, or represent it, if
it can be extended such that it leads from the root node of
the part to all its successors.

\begin{definition}[Part represented by an attack rule]
  A subtree $R ∈ P$ in a partition
  is said to be \emph{represented} by an
  attack rule $(p,q) \attack S$ if there exist $s,t ∈ \mc P$
  such that $T_r = (p⋅s,q⋅t)$
  and $\{ R'_r \mid R' ∈ succ_P(R) \} = \{ (p'⋅s,q'⋅t) \mid (p',q') ∈ S \}$
\end{definition}

Now we can prove our main theorem, which states that there is
an attack rule leading to the empty set for every closed tree.

\begin{theorem}
  \label{theorem:tree-attack}
  For an mvPDA $(\Dmay, \Dmust)$ with its induced MTS $(\mc P, \may[], \must[])$,
  it holds that for any $P,S,Q,R ∈ Const$:
  \[
    ∃ T : T_r = (P⋅S,Q⋅R) ∧ closed(T) \iff (P⋅S,Q⋅T) \attack ∅
  \]
\end{theorem}
\begin{proof}
    \Rightarrow: Assume $T$ to be closed tree with $T_r = (P⋅S,Q⋅R)$.

      First we show that if there is a partition $P = \{T'_1, …, T'_n\}$
      such that each part is represented by an attack rule, then
      there is an attack rule $(P⋅S, Q⋅T) \attack ∅$
      This is shown by induction on $n$:
      
      \begin{enumerate}
        \item $n = 1$: Then $P = \{T\}$ and there is a rule $(p,q) \attack S$
          representing $T$. As $(p⋅s,q⋅t) = T_r = (P⋅T,Q⋅R)$ and $|p| = |q| = 2$,
          we have $(p,q) = (P⋅T,Q⋅R)$ and as $succ_P(T) = ∅$ we have $S = ∅$.
          Then the rule is $(P⋅T, Q⋅R) \attack ∅$.
        \item $n > 1$:
          Let $T'$ be the subtree with $T'_r = (P⋅S, Q⋅R)$
          As $n > 1$, there is $T'' ∈ succ_P(T')$ where $T''_r = (p',q')$.
          Let $a = (P⋅S,Q⋅R) \attack S$ be the representing rule of $T'$.
          We have $(p',q') ∈ S$ and necessarily $|p'| = |q'| ≥ 2$, as otherwise
          there would be no rule applicable from that state and therefore $T''$ would not exist.
          So $a$ is a left-hand side rule.

          For every subtree $T'' ∈ P$ with $succ_P(T'') = ∅$,
          we have for the representing rule $b = (p,q) \rightarrow ∅$,
          so that is a right-hand side rule.
          Every path in $T$ eventually leads to such a subtree.

          Then by following the children of the subtrees from $T'$, we will eventually
          come to a subtree $T'$ succeded by a subtree $T''$ such that
          the rule represeenting $T'$ is a left-hand side rule and
          the rule representing $T''$ is a right-hand side rule.

          %As $S ∈ succ_P(R)$,
          %by lemma \ref{lemma:tree-composition}
          %we get a tree $R_0$ with $root(R_0) = root(R)$ and
          %$open(R_0) = open(R) ∖ \{ root(S) \} ∪ open(S)$.
          The partition $P' = P ∖ \{T'\}$ then is again a partition of $T$
          where $succ_{P'}(T') = succ_P(T') ∖ \{T''\} ∪ succ_P(T'')$ and
          other successors are unchanged.
          We now show that we can construct a rule representing $T'$ in $P'$:

          Let $a_1 = (p,q) \attack S$ be the rule representing $T'$ and
          $a_2 = (p',q') \attack S'$ be the rule representing $T''$.
          For $a_1$ for $T'$ we have that
          there is $s,t ∈ \mc P$ and $(p'',q'') ∈ S$ with $T''_r = (p''⋅s,q''⋅t)$.
          For $a_2$ we have that
          there is $s',t' ∈ \mc P$ with $T''_r = (p'⋅s',q'⋅t')$.

          Then $(p''⋅s,q''⋅t) = (p'⋅s',q'⋅t')$.
          As $2 ≤ |p''| = |q''| ≤ 3$ and $|p'| = |q'| = 2$ either
          $s = s'$ and $t = t'$ or $P⋅s = s'$ and $Q⋅t = t'$ for some $P,Q ∈ Const$.
          
          In the first case, we have $(p',q') = (p'',q'')$ and we can apply rule 3 to obtain
          $(p,q) \attack S ∖ \{(p'',q'')\} ∪ S'$.
          With $\{ (p'⋅s,q'⋅t) \mid (p',q') ∈ S ∖ \{(p'',q'')\} ∪ S' \} =
          \{ T'_r \mid succ_{P'}(T') \}$,
          it represents $T'$ in $P'$.

          In the second case, we have $(p'⋅P,q'⋅Q) = (p'',q'')$ and we can apply rule 4 to obtain
          $(p,q) \attack S ∖ \{(p'', q'')\} ∪ \{  (p''⋅P, q''⋅Q) \mid (p'',q'') ∈ S' \}$.
          With $\{ (p'⋅s,q'⋅t) \mid (p',q') ∈ S ∖ \{(p'',q'')\} \}$
          $∪ \{ (p''⋅P⋅s,q''⋅Q⋅t) \mid (p'',q'') ∈ S' \} =
          \{ T'_r \mid succ_{P'}(T') \}$,
          it represents $T'$ in $P'$.

          Then as $P'$ is a partition for $T$ having a rule representing each part
          with $n - 1$ elements, we can apply the induction hypothesis and obtain
          the rule is $(P⋅T, Q⋅R) \attack ∅$.
      \end{enumerate}

      Now we need to show there is an initial partition for $T$ represented
      by attack rules.
      If we initially take $P = subtrees(T)$, for each
      $T' ∈ P$ we have:
      There is an attacking transition from $T'_r$ which induced $R$.
      As $succ_P(R) = T'_C$, for each $T'' ∈ succ_P(T')$
      there is an appropriate defending transition to $T''_r$ and as
      $T'_O = ∅$ for each defending transition a $T'' ∈ succ_P(T')$ 

      Let $T'_t = (p⋅s,q⋅t)$ with $|p| = |q| = 2$.
      By lemma \ref{lemma:rule-lift}, for each transition
      $p⋅s \may[a] p'⋅s$ there is an inducing $(p, a, p') ∈ \Dmay$ and
      for each $q⋅t \may[a] q'⋅t$ there is an inducing $(q, a, q') ∈ \Dmay$.
      The same holds for $\must[a]$ and $\Dmust$.
      So there is a rule $(p, q) \attack \{ (p',q') \| (q, a, q') ∈ \Dmay \}$
      which represents $T'$.
    
    \Leftarrow:
      We show that if $(p,q) \attack S$, then there is a tree
      $T$ with $T_r = (p,q)$ such that $open(T) = S$
      by induction on the construction of $(p,q) \attack S$:
      \begin{enumerate}
        \item It was constructed by rule 1 from $(p, a, p') ∈ \Dmay$. Then there is
          an attacking transition $p \may[a] p'$ and 
          for every $(q, a, q') ∈ \Dmay$ there is an induced defending transition
          $q \may[a] q'$.
          Then $S = \{ (p',q') | q \may[a] q' \}$ and by attack tree inference rule 1
          there is $T = ((p, q), S, ∅)$ with $open(T) = S$.
        \item It was constructed by rule 2 from $(q, a, q') ∈ \Dmust$. Then there is
          an attacking transition $q \must[a] q'$ and 
          for every $(p, a, p') ∈ \Dmay$ there is an induced defending transition
          $p \must[a] p'$.
          Then $S = \{ (p',q') | p \may[a] p' \}$ and by attack tree inference rule 2
          there is $T = ((p, q), S, ∅)$ with $open(T) = S$.
        \item It was constructed by rule 3 from
          $(p,q) \attack S'' \uplus \{(p',q')\} $ and
          $(p',q') \attack S'$ with $S = S'' ∪ S'$.
          Then by induction hypothesis there is
          a tree $T'$ with $T'_r = (p',q')$ and $open(T') = S'$ and
          a tree $T''$ with $T''_r = (p,q)$ and $open(T'') = S'' \uplus \{(p',q')\}$.
          By applying lemma \ref{lemma:tree-composition} on $T'$ and $T''$ there is
          a tree $T$ with $T_r = (p,q)$ with $open(T) = S'' ∪ S' = S$.
        \item It was constructed by rule 4 from
          $(p,q) \attack S'' \uplus \{(p'⋅P,q'⋅Q)\}$ and
          $(p',q') \attack S'$ with $S = S'' ∪ S'''$ and
          $S''' = \{  (p''⋅P, q''⋅Q) \mid (p'',q'') ∈ S' \}$.
          Then by induction hypothesis there is
          a tree $T'$ with $T'_r = (p',q')$ and $open(T') = S'$ and
          a tree $T''$ with $T''_r = (p,q)$ and $open(T'') = S'' \uplus \{(p'⋅P,q'⋅Q)\}$.
          By applying lemma \ref{lemma:tree-lift} on $T'$ there is a tree
          $T'''$ with $T'''_r = (p'⋅P,q'⋅Q)$,
          $open(T''') = O''' \uplus \{(p'⋅P,q'⋅Q)\}$ and
          $O''' = \{ (p''⋅P, q''⋅Q) \mid (p'',q'') ∈ S' \} = S'''$.
          By applying lemma \ref{lemma:tree-composition} on $T''$ and $T'''$ there is
          a tree $T$ with $T_r = (p,q)$ and $open(T) = S'' ∪ S''' = S$.
      \end{enumerate}
      Therefore if $(P⋅S,Q⋅R) \attack ∅$, then there is a tree
      $T$ with $T_r = (P⋅S,Q⋅R)$ and $open(T) = ∅$.
\end{proof}

\begin{example}

\begin{figure}[ht]
  \centering
\begin{tikzpicture}[
  level 1/.style={level distance=1.5cm, sibling distance=2cm},
  edge from parent path={(\tikzparentnode.east) -- (\tikzchildnode.west)},
]
  \node[state] (R1) {$(P⋅S,Q⋅S) \attack[] \{ (P⋅M⋅S,Q⋅C⋅S), (P⋅M⋅S,Q⋅T⋅S) \}$};
  \node[attlabel, left of=R1] {$T_1$};
  
  \node[state, below of=R1, node distance=1cm] (R2) {$(P⋅M,Q⋅T) \attack[] \{ (P⋅M⋅M,Q⋅T⋅T) \}$};
  \node[attlabel, left of=R2] {$T_2$};

  \node[state, below of=R2, node distance=1cm] (R3) {$(P⋅M,Q⋅C) \attack[] \{ (P⋅M⋅M,Q⋅C⋅C) \}$};
  \node[attlabel, left of=R3] {$T_3$};

  \node[state, below of=R3, node distance=1cm] (R4) {$(P⋅M,Q⋅T) \attack[] \{ (C,Q) \} $};
  \node[attlabel, left of=R4] {$T_4$};

  \node[state, below of=R4, node distance=1cm] (R5) {$(P⋅M,Q⋅C) \attack[] \{ (T,Q) \} $};
  \node[attlabel, left of=R5] {$T_5$};
  
  \node[state, below of=R5, node distance=1cm] (R6) {$(C⋅M,Q⋅T) \attack[] ∅$};
  \node[attlabel, left of=R6] {$T_6$};
  
  \node[state, below of=R6, node distance=1cm] (R7) {$(T⋅M,Q⋅C) \attack[] ∅$};
  \node[attlabel, left of=R7] {$T_7$};
\end{tikzpicture}
  \caption{Attack rules for partition 1 of vending machine tree}
  \label{fig:vending-attackrule-tree-1}
\end{figure}

  Again we regard the vending machine mvPDA from figure \ref{fig:vending-mvpda}.
  We will see how to derive the attack tree from figure
  \ref{fig:vending-combined-attack-tree} with attack rules to prove that
  $P⋅S ≤_m Q⋅S$ does not hold.

\begin{figure}[ht]
  \centering
\begin{tikzpicture}[
  level 1/.style={level distance=1.5cm, sibling distance=2cm},
  edge from parent path={(\tikzparentnode.east) -- (\tikzchildnode.west)},
]
  \node[state] (R1) {$(P⋅S,Q⋅S) \attack[] \{ (P⋅M⋅S,Q⋅C⋅S), (P⋅M⋅S,Q⋅T⋅S) \}$};
  \node[attlabel, left of=R1] {$T_1$};
  
  \node[state, below of=R1, node distance=1cm] (R2) {$(P⋅M,Q⋅T) \attack[] \{ (C⋅M,Q⋅T) \}$};
  \node[attlabel, left of=R2] {$T_2$}
  child {
    node {$T_4$}
  };

  \node[state, below of=R2, node distance=1cm] (R3) {$(P⋅M,Q⋅C) \attack[] \{ (T⋅M,Q⋅C) \}$};
  \node[attlabel, left of=R3] {$T_3$}
  child {
    node {$T_5$}
  };
  
  \node[state, below of=R3, node distance=1cm] (R6) {$(C⋅M,Q⋅T) \attack[] ∅$};
  \node[attlabel, left of=R6] {$T_6$};
  
  \node[state, below of=R6, node distance=1cm] (R7) {$(T⋅M,Q⋅C) \attack[] ∅$};
  \node[attlabel, left of=R7] {$T_7$};
\end{tikzpicture}
  \caption{Attack rules for partition 2 of vending machine tree}
  \label{fig:vending-attackrule-tree-2}
\end{figure}

  Initially we take the finest partition of the attack tree, where every
  node has to a basic attack rules representing it, as shown in figure 
  \ref{fig:vending-attackrule-tree-1}.
  Note that the rules from $T_1$, $T_2$, and $T_3$ are left-hand side rules
  and the rules from $T_4$, $T_5$, $T_6$, $T_7$ are right-hand side rules.
  So the only we can combine are the ones from $T_2$ with $T_4$ and
  $T_3$ with $T_5$. Then we obtain the partition and rules shown in
  figure \ref{fig:vending-attackrule-tree-2}.

\begin{figure}[ht]
  \centering
\begin{tikzpicture}[
  level 1/.style={level distance=1.5cm, sibling distance=2cm},
  level 2/.style={level distance=1.5cm, sibling distance=2cm},
  edge from parent path={(\tikzparentnode.east) -- (\tikzchildnode.west)},
]
  \node[state] (R1) {$(P⋅S,Q⋅S) \attack[] \{ (P⋅M⋅S,Q⋅C⋅S), (P⋅M⋅S,Q⋅T⋅S) \}$};
  \node[attlabel, left of=R1] {$T_1$};
  
  \node[state, below of=R1, node distance=1cm] (R2) {$(P⋅M,Q⋅T) \attack[] ∅ \}$};
  \node[attlabel, left of=R2] {$T_2$}
  child {
    node {$T_4$}
    child {
      node {$T_6$}
    }
  };

  \node[state, below of=R2, node distance=1cm] (R3) {$(P⋅M,Q⋅C) \attack[] ∅$};
  \node[attlabel, left of=R3] {$T_3$}
  child {
    node {$T_5$}
    child {
      node {$T_7$}
    }
  };
\end{tikzpicture}
  \caption{Attack rules for partition 3 of vending machine tree}
  \label{fig:vending-attackrule-tree-3}
\end{figure}

  After that we can combine the rules from $T_2$ with $T_6$ and from $T_3$
  with $T_7$. This results in the rules shown in
  figure \ref{fig:vending-attackrule-tree-3}.
  Finally we combine $T_1$ first with $T_2$ and then with $T_3$ to obtain
  the rule shown in figure \ref{fig:vending-attackrule-tree-2}, which
  represents the whole tree. With this we can decide that there is
  a winning strategy from $(P⋅S, Q⋅S)$, therefore the states do not refine.

\begin{figure}[ht]
  \centering
\begin{tikzpicture}[
  level 1/.style={level distance=1.5cm, sibling distance=2cm},
  level 2/.style={level distance=1.5cm, sibling distance=2cm},
  level 3/.style={level distance=1.5cm, sibling distance=2cm},
  edge from parent path={(\tikzparentnode.east) -- (\tikzchildnode.west)},
]
  \node[state] (R1) {$(P⋅S,Q⋅S) \attack[] ∅$};
  \node[attlabel, left of=R1] {$T_1$}
  child {
    node {$T_3$}
    child {
      node {$T_5$}
      child {
        node {$T_7$}
      }
    }
  }
  child {
    node {$T_2$}
    child {
      node {$T_4$}
      child {
        node {$T_6$}
      }
    }
  };
\end{tikzpicture}
  \caption{Attack rules for partition 4 of vending machine tree}
  \label{fig:vending-attackrule-tree-4}
\end{figure}

\end{example}

