\chapter{Theory}

\section{Basic definitions}

 process rewrite systems \cite{Mayr00, Esparza01}. % TODO

% processes are parallel or sequential

\begin{definition}[Process]

The set of processes $\mc P$ over a set of constants $Const$ is given by
\begin{mathpar}
  \inferrule{ }{ε ∈ \mc P}\, (0) \hspace{1cm}
  \inferrule{X ∈ Const}{X ∈ \mc P}\, (1) \hspace{1cm}
  \inferrule{p ∈ \mc P \\ q ∈ \mc P}{p⋅q ∈ \mc P}\, (S) \hspace{1cm}
  \inferrule{p ∈ \mc P \\ q ∈ \mc P}{p\|q ∈ \mc P}\, (P)
\end{mathpar}
Processes are considered modulo the usual structural congruence, i.e.
the smallest congruence such that the operator $⋅$ is associative,
$\|$ is associative and commutative and
$ε$ is a unit for both $⋅$ and $\|$.

From here on we will denote processes by lowercase letters $p,q,…$ and single
constants by uppercase letters $P,Q,…$.
\end{definition}

The class of processes that can be produced just with rule 0, 1 and S, i.e. contain no $\|$,
is the class of \emph{sequential processes} \textbf{S}.
The class of processes that can be produced just with rule 0, 1 and P, i.e. contain no $⋅$,
is the class of \emph{parallel processes} \textbf{P}.
% TODO add constant or general processes?

\begin{definition}[Size of a process]
  The size $|p|$ of a process term $p$ is defined by
  \begin{align*}
    |ε| &= 0 \\
    |X| &= 1 \\
    |p⋅q| &= |p| + |q| \\
    |p \| q| &= |p| + |q|
  \end{align*}
\end{definition}

%\begin{definition}[Constants of a process term]
%  The set of constants $Const(p)$ appearing in a process term $p$ is defined by
%  \begin{align*}
%    Const(ε) &= ∅ \\
%    Const(X) &= \{ X \} \\
%    Const(p⋅q) &= Const(p) ∪ Const(q) \\
%    Const(p\|q) &= Const(p) ∪ Const(q) \\
%  \end{align*}
%\end{definition}

\section{Modal transition system}

%Modal process rewrite systems \cite{BenesK12} are a modal extension of 

Modal transition system definition from \cite{BenesK12}:
\begin{definition}[Modal transition system]
A \emph{modal transition system (MTS)} over an action alphabet $Act$ is
a triple $(\mc P, \may[], \must[])$ where $\mc P$ is a set of processes %TODO tripel? tuple?
$\must[] ⊆ \may[] ⊆ \mc P × Act × \mc P$.
An element $(p,a,q) ∈ \may[]$ is a \emph{may transition}, also written as $p \may[a] q$,
and an element $(p,a,q) ∈ \must[]$ is a \emph{must transition}, also written as $p \must[a] q$.
\end{definition}

\section{Modal refinement}

\begin{definition}[Refinement]
  Let $(\mc P, \may, \must)$ be an MTS
  and $p,q ∈ \mc P$ be processes.
  We say that $p$ \emph{refines} $q$, written $p ≤_m q$, if there is a relation
  $\mc R ⊆ \mc P × \mc P $ such that
  $(p, q) ∈ \mc R$ and for every $(p, q) ∈ \mc R$ and every $a ∈ Act$:
  \begin{enumerate}
    \item If $p \may[a] p'$ then there is a transition $q \may[a] q'$ s.t.
          $(p',q') ∈ \mc R$.
    \item If $q \must[a] q'$ then there is a transition $p \must[a] p'$ s.t.
          $(p',q') ∈ \mc R$.
  \end{enumerate}
\end{definition}

Modal refinement can also be seen as a refinement game from a pair of processes
$(p,q)$ where each side plays an attacking transition and the other a defending transition
to reach a new state.
The attacker wins if there is a strategy of attacking transitions where the
defender always ends up in state where there are no defending transitions, otherwise
the defender wins.

\begin{definition}[Refinement game]
  Let $(\mc P, \may, \must)$ be an MTS
  and $p,q ∈ \mc P$ be processes.

  We define the set of \emph{attacking transitions}
  $Att = \{ (p, q, p \may[a] p') \mid p \may[a] p' \} ∪
                 \{ (p, q, q \must[a] q') \mid q \may[a] q' \}$.
  
  For an attacking transition $r ∈ Att$, the defending
  transitions are \\
  we will make use of that notion
  \[
  Def((p, q, r)) = \begin{cases}
    \{ (q \may[a] q', p', q') \mid q \may[a] q' \} & \text{if }r = p \may[a] p' \\
    \{ (p \must[a] p', p', q') \mid p \must[a] p' \} & \text{if }r = q \must[a] q'
  \end{cases}
  \]
  Then if $(p,q,r) ∈ Att$ and $(p',q') ∈ Def((p,q,r))$ we would
  get an attack transition $(p,q) \attack[r,r'] (p',q')$.
  % TODO rewrite

  With that we can say that $p ≤_m q$ if there is a relation
  $\mc R ⊆ \mc P × \mc P $ such that
  $(p, q) ∈ \mc R$ and for every $(p,q,r) ∈ Att$ if $(p, q) ∈ \mc R$ then there
  is $(p',q') ∈ Def((p,q,r))$ such that $(p',q') ∈ \mc R$.
\end{definition}
% modal refinement of two MTS

\section{Modal process rewrite system}

\begin{definition}[Modal process rewrite system]
A \emph{process rewrite system (PRS)} over an action alphabet $Act$
is a finite relation $Δ ⊆ \mc P ∖ \{ε\} × Act × \mc P$
Elements of $Δ$ are called \emph{rewrite rules}.
A \emph{modal process rewrite system (mPRS)} is a tuple $(\Dmay, \Dmust)$ where
$\Dmay, \Dmust$ are process rewrite systems such that $\Dmay ⊆ \Dmust$.

An mPRS $(\Dmay, \Dmust)$ induces an MTS $(\mc P, \may[], \must[])$ as follows:
\begin{mathpar}
  \inferrule{(p, a, p') ∈ \Dmay}{p \may[a] p'} \, (1) \quad
  \inferrule{(p, a, p') ∈ \Dmust}{p \must[a] p'} \, (2) \\
  \inferrule{p \may[a] p'}{p⋅q \may[a] p⋅q} \, (3) \quad
  \inferrule{p \must[a] p'}{p⋅q \must[a] p'⋅q} \, (4) \quad
  \inferrule{p \may[a] p'}{p\|q \may[a] p\|q} \, (5) \quad
  \inferrule{p \must[a] p'}{p\|q \must[a] p'\|q} \, (6)
\end{mathpar}
\end{definition}

\section{Attack tree}

\begin{definition}[Attack tree]

  An \emph{attack tree} over a set of processes $\mc P$ is a rooted tree where
  each node has two kinds of children.
  It is given by a triple $(s,O,C)$,
  representing the tree with the root node labeled by $s ∈ \mc P^2$,
  the set of open edges $O$ leading to states $s' ∈ \mc P^2$ and
  the set of closed edges $C$ leading to the attack trees that are children of the
  root node.
  
%  labeled with the attack transition $s ∈ Att$,
%  and each edge labeled with a defending transition leads to a child tree
%m  or an element $\{(p',q')\}$
%  $O ⊆ Def(s)$ is a set of open edges labeled
%  and $C ⊆ Def(s) × \mc T$ is the set of closed edges labeled with a defending
%  transition and leading to a child tree in $\mc T$, the set of all trees.

  The set of attack trees $\mc T$ constructable from an MTS $(\mc P, \may, \must)$
  are defined inductively by
  \begin{mathpar}
    \inferrule{p,q ∈ \mc P, p \may[a] p'}
      {((p,q), \{ (p', q') \mid q \may[a] q' \}, ∅) ∈ \mc T}
    \, (1) \\
    \inferrule{p,q ∈ \mc P, q \must[a] q'}
      {((p,q), \{ (p', q') \mid p \must[a] q' \}, ∅) ∈ \mc T}
    \, (2) \\
    \inferrule{((p,q), O \uplus (p', q'), C) ∈ \mc T \\ T = (p', q'), O', C') ∈ \mc T}
      {(s, O, C ∪ T) ∈ \mc T}
    \, (3) \\
%    \inferrule{(p,q,r) ∈ Att}
%      {((p,q), \{ (p', q') \mid (r', p', q') ∈ Def(s) \}, ∅) \atree}
%    \, (1) \\
%    \inferrule{((p,q), O \uplus (p', q'), C) \atree \\ T = (p', q'), O', C') \atree}
%      {(s, O, C ∪ T) \atree}
%    \, (2) \\
%    \inferrule{T \atree \\ ∃ n ∈ T : n = (s, C \uplus \{p',q')\} is a tree with a node N with an open edge to (p',q')
%    and T' is a tree with root (p',q')}
%    {T'' is a tree obtained by replacing the node N with a node having the
%    open edge replaced by an edge to T'}
    \inferrule{(s, O \uplus (r', p', q'), C) ∈ \mc T \\ ((p', q', r''), O', C') ∈ \mc T}
      {(s, O, C ∪ \{(r', (p', q', r''), O', C')\}) \in \mc T} \, (2) \\
  \end{mathpar}
%  An \emph{attack tree} is given by its node $(p, q, r) ∈ $,
%  a set of open edges $O ⊆ \mc P^2 × (\may ∪ \must)$ and set
%  of closed edges to children $C ⊆ \mc (P^2 × (\may ∪ \must)) × \mathcal T$ where
%  $\mc T$ is the set of trees. They are defined inductively by
  
  Rules 1 and 2 specify an initial tree for an attacking rule with the possible defensive
  states while rule 3 replaces an open edge to a state with a tree with that state as its
  root.
  As we can see from the construction rules, every node $(p,q)$ in the tree corresponds
  to an attacking transition applicable from that state, while the set of edges from that node
  corresponds exactly to the defending transition applicable from that state and attacking transition.

  For an attack tree $T = ((p,q),O,C)$, the root is given by $root(T) = (p,q)$.
  We define the set of \emph{open states} by the states that
  have an open edge to it, that is
  $open(((p,q,r), O, C)) = O ∪ ⋃_{T' ∈ C} open(T')$.
  We say that a tree is \emph{closed} if it has no open states, that is
  $closed(T)$ \iff $open(T) = ∅$.

  %The set of successors from the root node of a tree is given by
  %$succ((p,q), O, C) = O ∪ \{(p',q') \mid ((p',q'), O', C') ∈ C$.

  %For a closed attack tree, we can define
  %a) a node $c$ is a child of $r$ if there is a non-empty path from $r$ to $c$.
  
  %A partition $P$ of a tree is given by a set of nodes $P = \{T_1, …, T_n\}$.
  %The part represented by $T_i ∈ P$ is the node $T_i$ and all nodes that are successors
  %of $T_i$ but not of another $T_j ∈ P$.

  %$(p,q) \attack S$ is said to represent a partition $T$ if
  %$∃ s,t ∈ \mc P$ such that $(p⋅s,q⋅t) = T$ and
  %with $C = \{ T' ∈ P \mid T \attack T' \}$ $\{(p⋅s,q⋅t) | (p,q) ∈ S \} = C$.

  %b) a subtree
  %as a tupel $(r,C)$ where $r$ is a node in the tree and $C$ is a set of
  %nodes such that each $c ∈ C$ is a child of $r$ but no child of another $c ∈ C$.
  %The subtree is then the tree given by $r$ and the paths from $r$ to each $c ∈ C$.
  %The set $C$ may be empty, in which case the subtree is just the node $r$.
\end{definition}

\begin{lemma}
  \label{lemma:tree-composition}
  If there are attack trees $T$ with $root(T) = (p,q)$ and
  $R$ with $root(R) = (p',q')$ and $(p',q') ∈ open(T)$,
  then there is an attack tree $S$ with
  $root(S) = (p,q)$ and $open(S) = open(T) ∖ \{(p', q')\} ∪ open(R)$
\end{lemma}
\begin{lemma}
  \label{lemma:tree-composition2}
  If there are attack trees $T = ((p,q), O, C)$ and
  $R = ((p',q'), O', C')$ with $(p',q') ∈ open(T)$,
  then there is an attack tree $S$ with
  $S = ((p,q), O' ∖ \{p',q'\}, C'')$ with
  $open(S) = open(T) ∖ \{(p', q')\} ∪ open(R)$
\end{lemma}
\begin{proof}
  We prove the proposition by induction on $T$:
  \begin{enumerate}
    \item $T = ((p,q), O, ∅)$:
      Then $(p',q') ∈ O$ and we can construct
      $S = ((p,q), O ∖ \{(p',q')\}, \{R\}$ with
      $open(S) = open(T) ∖ \{(p', q')\} ∪ open(R)$
    \item $T = ((p,q), O, C ∪ T'')$ from
        $T' = ((p,q), O \uplus \{(p'',q'')\}, C)$ and
        $T'' = (p'',q''), O'', C'')$.
        $open(T) = open(T') ∖ \{(p'',q'')\} ∪ open(T'')$

        If $(p',q') ∈ open(T')$, by induction hypothesis we get
        $S' = ((p,q), (O \uplus \{(p'',q'')\}) ∖ \{(p', q'\}, C')$ with
        $open(S') = open(T') ∖ \{(p', q')\} ∪ open(R)$.
        %$open(S') = ((open(T') ∖ \{(p', q')\}) \uplus \{(p'',q'')\}, C')$.
        %else set $S' = T'$.
        
        If $(p',q') ∈ open(T'')$, by induction hypothesis we get
        $S''$ with $root(S'') = (p'',q'')$ and
        $open(S'') = open(T'') ∖ \{(p', q')\} ∪ open(R)$.
        else set $S'' = T''$.
        
        As $(p',q') ∈ open(T)$, if $(p',q') ∈ O$, then $(p',q') ≠ (p'',q'')$. Therefore
        $S' = ((p,q), (O ∖ \{(p', q')\}) \uplus, C')$.
        Then from $S'$ and $S''$ construct
        $S = ((p,q), O ∖ \{(p'',q'')\} ∖ \{(p', q'\} , C ∪ S'')$ with
        $open(S) = open(S') ∖ \{(p'', q'')\} ∪ open(S'')$.
        $= (open(T') ∖ \{(p', q')\} ∖ \{(p'',q'')\}  ∪ open(R))$
        $∪ (open(T'') ∖ \{(p', q')\} ∪ open(R))$
        $= ((open(T') ∖ \{(p'',q'')\} ∪ open(T'')) ∖ \{(p', q')\}) ∪ open(R))$.
  \end{enumerate}
  % todo
  By replacing all nodes $((p'',q''), O', C')$ where
  $(p',q') ∈ O'$ with $((p'',q''), O ∖ \{(p', q')\}, C' ∪ R)$.
\end{proof}

% todo relation tree <-> refinement

\begin{theorem}
  \label{theorem:refinement-tree}
  For an MTS $(\mc P, \may, \must)$ and processes $p,q ∈ \mc P$:
  \[
    (p ≤_m q) \iff ¬∃ T ∈ \mc T : root(T) = (p,q) ∧ closed(T)
  \]
\end{theorem}

\begin{proof}
    \Rightarrow: Assume $p ≤_m q$. Then there is a refinement relation $\mc R$.
      To show that for $(p,q) ∈ \mc R$ there is no closed tree from $(p,q)$, we
      show for any $T$ with $root(T) = (p, q)$, if $T$ is closed, then $(p, q) ∉ R$.
     
      Let $r$ be the attacking transition corresponding to $(p,q)$ in $T$.
      For every fitting defending transition $r'$ to $(p',q')$ there is an edge
      from $(p,q)$ to $(p',q')$.
      As $T$ is closed, with $open(T) = O ∪ ⋃_{T'∈C}open(T') = ∅$ we get $O = ∅$
      and every $T'$ is closed.

      Now we show the proposition by induction over the number of children $|C|$:
      \begin{enumerate}
        \item $|C| = 0$: Then there is an attacking transition, but no
          defending transition, therefore $(p,q) ∉ \mc R$.
        \item $|C| ≥ 1$:
          Then there is an attacking rule, and for every defending transition leading
          to $(p',q')$, there is an edge to a closed tree $T'$ with $root(T') = (p',q')$.
          By induction hypothesis we have $(p',q') ∉ \mc R$ and therefore $(p,q) ∉ \mc R$.
      \end{enumerate}
    \Leftarrow: Assume there is no closed attack tree $T$ with $root(T) = (p,q)$.
      To show $p ≤_m q$, we show that $\mc R := \{ (p',q') \mid ¬∃ T : root(T) = (p',q') ∧ closed(T) \}$ is a valid
      refinement relation with $(p,q) ∈ \mc R$.

      For any attacking transition $r$ and $(p,q) ∈ \mc R$,
      by inference rule 1 or 2 there exists an attacking tree $T = ((p,q), O, C)$.
      From all such $T$ with $root(T) = (p,q)$, choose one where $O$ is minimal
      with regard to the inclusion order.
      There exists $(p',q') ∈ O$ with $(p',q') ∈ \mc R$, because otherwise
      there would be a closed attack tree $T'$ with $root(T') = (p',q')$ and
      by inference rule 3 we would get
      $T'' = ((p,q), O'', C ∪ T')$ with $O'' = O ∖ \{(p',q')\} ⊊ O$
      in contradiction to the minimality of $O$.
      So for the attacking transition $(p,q)$ there is a defending transition
      $(p',q')$ with $(p',q') ∈ \mc R$.
\end{proof}

% tree used to decide refinement

\section{Visibly pushdown automaton}

% tree not computable

\begin{definition}[Visibly pushdown automaton]
A PRS $Δ$ over the action alphabet $Act$ is a
\emph{visibly pushdown automaton (vPDA)} if
there is a partition
$Act = Act_r \uplus Act_i \uplus Act_c$
such that every rule $(p, a, p') ∈ Δ$ has the form
\begin{align*}
  p &= P⋅S
  & &\text{and} &
  p' &= \begin{cases}
  Q & \text{if } a ∈ Act_r \quad \text{(return rule)}\\
  Q⋅T & \text{if } a ∈ Act_i \quad \text{(internal rule)} \\
  Q⋅T⋅R & \text{if } a ∈ Act_c \quad \text{(call rule)}
\end{cases}
\end{align*}
A \emph{modal visibly pushdown automaton (mvPDA)} is then an
mPRS $(\Dmay, \Dmust)$ such that $\Dmust$ is a vPDA.
\end{definition}

\begin{definition}[Attack rule]
  Let $(\Dmay, \Dmust)$ be an mvPDA.
  An \emph{attack rule} $(p,q) \attack S$ with $p,q ∈ \mc P$ and $S ⊆ \mc P$
  is obtainable from the rewrite rules if it can be constructed by the following rules:
  \begin{mathpar}
    \inferrule{(p, a, p') ∈ \Dmay}{(p,q) \attack \{ (p', q') \mid (q, a, q') ∈ \Dmay \}}
      \, (1) \\
    \inferrule{(q, a, q') ∈ \Dmust}{(p,q) \attack \{ (p', q') \mid (p, a, p') ∈ \Dmust \}}
      \, (2) \\
    \inferrule{(p,q) \attack \{(p'⋅P,q'⋅Q)\} \uplus S \\ (p',q') \attack S' \\
      ∀(p'',q'') ∈ S' : |p''| = 1 }
      {(p,q) \attack S ∪ \{  (p''⋅P, q''⋅Q) \mid (p'',q'') ∈ S' \}} \, (3) \\
    \inferrule{(p,q) \attack \{(p',q')\} \uplus S \\ (p',q') \attack S' \\
      ∀(p'',q'') ∈ S' : |p''| = 1 }
      { (p,q) \attack S ∪ S'} \, (4)
  \end{mathpar}

  Due to the constrainst on the rewrite rules of an mvPDA and the construction of the
  attack rules, we can see that for any element $(p,q) \attack S$ it holds that
  $|p| = |q| = 2$ and for any $(p',q') ∈ S$ that $1 ≤ |p'| = |q'| ≤ 3$.
  
  When the rules 3 and 4 always combine a rule $(p,q) \attack S \uplus \{(p',q')\}$
  on the left and rule $(p',q') \attack S'$ on right, it always holds that
  $|p'| = 2$ or $|p'|$ = 3 and for all $(p'',q'') ∈ S'$ $|p''| = 1$.
  We will call a rule $p \attack S$ a \emph{right-hand side} rule if
  $∀(p',q') ∈ S: |p'| = 1$ and otherwise a \emph{left-hand side} rule.
  This partitions the set of rules into two classes.
\end{definition}

\begin{lemma}
  \label{lemma:tree-lift}
  Given an MTS generated by a mvPDA,
  if there is an
  attack tree $T$ with $root(T) = (p,q)$,
  then for any $s,t ∈ \mc P$, there is an
  attack tree $R$ with $root(R) = (p⋅s, q⋅t)$ and
  $open(R) = \{ (p'⋅s,q'⋅t) \mid (p', q') ∈ open(T) \}$.
\end{lemma}
\begin{proof}
  As $p$ and $q$ are the left-hand side of some rewrite rule,
  we have $|p| ≥ 2$ and $|q| ≥ 2$.
  Then by looking at the induction rules for an MTS from an mPRS, we have that
  if $p \may[a] p'$, then $p⋅s \may[a] p'⋅s$ and
  if $p⋅s \may[a] p'⋅s$, then $p \may[a] p'$, therefore
  $\{ p⋅s \may[a] p'⋅s \mid p \may[a] p' \} = \{ p⋅s \may[a] p'⋅s \}$.
  The same holds for $\must$.
  
  We then prove the proposition by induction on $T$:
  \begin{enumerate}
    \item $T = ((p,q), O, ∅)$ from $p \may[a] p'$ with
      $O = \{ (p', q') \mid q \may[a] q'\}$.
      Then also $p⋅s \may[a] p⋅s'$ and with
      $O' = \{ (p'⋅s, q'⋅t \mid  q⋅t \may[a] q'⋅t \}$
      $ = \{ (p'⋅s, q'⋅t \mid  q \may[a] q' \}$
      $ = \{ (p'⋅s, q'⋅t \mid  (p',q') ∈ O \}$
      we can construct $R = ((p'⋅s,q'⋅t), O', ∅)$.
    \item $T = ((p,q), O, ∅)$ from $q \must[a] q'$.
      This case is symmetric to the first one.
    \item $T = ((p,q), O, C ∪ T'')$ from
        $T' = ((p,q), O \uplus \{(p',q')\}, C)$ and
        $T'' = (p',q'), O', C')$.
        By induction hypothesis we get
        $R' = ((p⋅s,q⋅t), O' \uplus \{(p'⋅s,q'⋅t)\}, C')$ and
        $R'' = (p'⋅s,q'⋅t), O'', C')$.
        Then we can construct
        $R = ((p⋅s, q⋅t), O, C' ∪ R'')$ with
        $open(R) = open(R') ∖ \{(p'⋅s,q⋅t)\} ∪ open(R'')$
        $= \{ (p'⋅s, q'⋅t) \mid (p',q') ∈ open(T') \} ∖ \{(p'⋅s,q'⋅t)\}$
        $∪ \{ (p''⋅s, q''⋅t) \mid (p'',q'') ∈ open(T'') \}$
        $= \{ (p''⋅s, q''⋅t) \mid (p'',q'') ∈ open(T') ∖ \{p',q'\} ∪ open(T'') \}$
        $= \{ (p''⋅s, q''⋅t) \mid (p'',q'') ∈ open(T) \}$
  \end{enumerate}
\end{proof}

\begin{theorem}
  \label{theorem:tree-attack}
  For an mvPDA $(\Dmay, \Dmust)$ with its induced MTS $(\mc P, \may[], \must[])$,
  it holds that for any $P,S,Q,R ∈ Const$:
  \[
    ∃ T : root(T) = (P⋅S,Q⋅R) ∧ closed(T) \iff (P⋅S,Q⋅T) \attack ∅
  \]
\end{theorem}
\begin{proof}
    \Rightarrow: Assume $T$ to be closed tree with $root(T) = (P⋅S,Q⋅T)$.

      We show that for any partition of the tree $P = \{T_1, …, T_n\}$ where
      every $T_i$ is represented by a rule $b_i$, there is
      an attack rule representing the whole tree.
      Proof by induction over the length of the partition $n$:
      \begin{enumerate}
        \item $n = 1$: Then $T_1 = T$ and $b_1$ represents $T$.
        \item $n > 1$: WLOG let $T_1 = (P⋅S, Q⋅T)$
          be the part at the root of the tree $T$ with succeding partitions $C$.
          
          As $n > 1$, there is $(p', q', r') ∈ C$.
          Then for $b_1 = (P⋅S,Q⋅T) \attack S$ we have by representation
          $(p', q') ∈ S$
          and we have $|p'| = |q'| ≥ 2$, as otherwise the rule $r'$ would
          not be applicable from the state $(p', q')$. So $b_1$ is a left-hand side rule.

          For every partition $T_i$ with no succeding partitions, we have
          $b_i = (p,q) \rightarrow ∅$, so that is a right-hand side rule.

          Then by following the successors of the partitions from $T_1$, we will eventually
          come to a partition $T_i$ followed by a partition
          $T_j$ such that
          $b_i$ is a left-hand side rule and $b_j$ is a right-hand side rule.
          
          Then by rule 3 or 4 we can combine $b_i$ and $b_j$ into a new rule $b_0$.
          This rule represents the partition $T_i$ in $P' = P ∖ \{T_j\}$. Every
          other $T_k ∈ P'$ remains unchanged and is still represented by $b_k$.
          Then by induction hypothesis there is a $b$ representing $T$.

      \end{enumerate}

      %show: every closed tree has a partition with a representation by b_i
      
    \Leftarrow:
      We show that if $(p,q) \attack S$, then there is a tree
      $T$ with $root(T) = (p,q)$ such that $open(T) = S$
      by induction on the construction of $(p,q) \attack S$:
      \begin{enumerate}
        \item It was constructed by rule 1 from $(p, a, p') ∈ \Dmay$. Then there is
          an attacking transition $p \may[a] p'$ and 
          for every $(q, a, q') ∈ \Dmay$ there is an induced defending transition
          $q \may[a] q'$.
          Then $S = \{ (p',q') | q \may[a] q' \}$ and by attack tree inference rule 1
          there is $T = ((p, q), S, ∅)$ with $open(T) = S$.
        \item It was constructed by rule 2 from $(q, a, q') ∈ \Dmust$. Then there is
          an attacking transition $q \must[a] q'$ and 
          for every $(p, a, p') ∈ \Dmay$ there is an induced defending transition
          $p \must[a] p'$.
          Then $S = \{ (p',q') | p \may[a] p' \}$ and by attack tree inference rule 2
          there is $T = ((p, q), S, ∅)$ with $open(T) = S$.
        \item It was constructed by rule 3 from
          $(p,q) \attack \{(p'⋅P,q'⋅Q)\} \uplus S''$ and
          $(p',q') \attack S'$ with $S = S'' ∪ S'''$ and
          $S''' = \{  (p''⋅P, q''⋅Q) \mid (p'',q'') ∈ S' \}$.
          Then by induction hypothesis there is
          a tree $T'$ with $root(T') = (p',q')$ and $open(T') = S'$ and
          a tree $T''$ with $root(T'') = (p,q)$ and $open(T'') = S'' \uplus \{(p'⋅P,q'⋅Q)\}$.
          By appying lemma \ref{lemma:tree-lift} on $T'$ there is a tree
          $T'''$ with $root(T''') = (p'⋅P,q'⋅Q)$,
          $open(T''') = O''' \uplus \{(p'⋅P,q'⋅Q)\}$ and
          $O''' = \{ (p''⋅P, q''⋅Q) \mid (p'',q'') ∈ S' \} = S'''$.
          By applying lemma \ref{lemma:tree-composition} on $T''$ and $T'''$ there is
          a tree $T$ with $root(T) = (p,q)$ and $open(T) = S'' ∪ S''' = S$.
        \item It was constructed by rule 4 from
          $(p,q) \attack S'' \uplus \{(p',q')\} $ and
          $(p',q') \attack S'$ with $S = S'' ∪ S'$.
          Then by induction hypothesis there is
          a tree $T'$ with $root(T') = (p',q')$ and $open(T') = S'$ and
          a tree $T''$ with $root(T'') = (p,q)$ and $open(T'') = S'' \uplus \{(p',q')\}$.
          By applying lemma \ref{lemma:tree-composition} on $T'$ and $T''$ there is
          a tree $T$ with $root(T) = (p,q)$ with $open(T) = S'' ∪ S' = S$.
      \end{enumerate}
      Therefore if $(P⋅S,Q⋅T) \attack ∅$, then there is a tree
      $T$ with $root(T) = (P⋅S,Q⋅T)$ and $open(T) = ∅$.
\end{proof}

% theory and background

